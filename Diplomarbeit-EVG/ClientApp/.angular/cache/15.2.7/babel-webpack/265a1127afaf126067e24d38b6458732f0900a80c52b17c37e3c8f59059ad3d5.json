{"ast":null,"code":"/*\n * Copyright 2010 ZXing authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n    return extendStatics(d, b);\n  };\n  return function (d, b) {\n    extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\nvar __values = this && this.__values || function (o) {\n  var s = typeof Symbol === \"function\" && Symbol.iterator,\n    m = s && o[s],\n    i = 0;\n  if (m) return m.call(o);\n  if (o && typeof o.length === \"number\") return {\n    next: function () {\n      if (o && i >= o.length) o = void 0;\n      return {\n        value: o && o[i++],\n        done: !o\n      };\n    }\n  };\n  throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\n/*namespace com.google.zxing.oned {*/\nimport BarcodeFormat from '../BarcodeFormat';\nimport ChecksumException from '../ChecksumException';\nimport FormatException from '../FormatException';\nimport NotFoundException from '../NotFoundException';\nimport OneDReader from './OneDReader';\nimport Result from '../Result';\n//import com.google.zxing.ResultMetadataType;\nimport ResultPoint from '../ResultPoint';\n/**\n * <p>Decodes Code 93 barcodes.</p>\n *\n * @author Sean Owen\n * @see Code39Reader\n */\nvar Code93Reader = /** @class */function (_super) {\n  __extends(Code93Reader, _super);\n  //public Code93Reader() {\n  //  decodeRowResult = new StringBuilder(20);\n  //  counters = new int[6];\n  //}\n  function Code93Reader() {\n    var _this = _super.call(this) || this;\n    _this.decodeRowResult = '';\n    _this.counters = new Int32Array(6);\n    return _this;\n  }\n  Code93Reader.prototype.decodeRow = function (rowNumber, row, hints) {\n    var e_1, _a, e_2, _b;\n    var start = this.findAsteriskPattern(row);\n    // Read off white space\n    var nextStart = row.getNextSet(start[1]);\n    var end = row.getSize();\n    var theCounters = this.counters;\n    theCounters.fill(0);\n    this.decodeRowResult = '';\n    var decodedChar;\n    var lastStart;\n    do {\n      Code93Reader.recordPattern(row, nextStart, theCounters);\n      var pattern = this.toPattern(theCounters);\n      if (pattern < 0) {\n        throw new NotFoundException();\n      }\n      decodedChar = this.patternToChar(pattern);\n      this.decodeRowResult += decodedChar;\n      lastStart = nextStart;\n      try {\n        for (var theCounters_1 = (e_1 = void 0, __values(theCounters)), theCounters_1_1 = theCounters_1.next(); !theCounters_1_1.done; theCounters_1_1 = theCounters_1.next()) {\n          var counter = theCounters_1_1.value;\n          nextStart += counter;\n        }\n      } catch (e_1_1) {\n        e_1 = {\n          error: e_1_1\n        };\n      } finally {\n        try {\n          if (theCounters_1_1 && !theCounters_1_1.done && (_a = theCounters_1.return)) _a.call(theCounters_1);\n        } finally {\n          if (e_1) throw e_1.error;\n        }\n      }\n      // Read off white space\n      nextStart = row.getNextSet(nextStart);\n    } while (decodedChar !== '*');\n    this.decodeRowResult = this.decodeRowResult.substring(0, this.decodeRowResult.length - 1); // remove asterisk\n    var lastPatternSize = 0;\n    try {\n      for (var theCounters_2 = __values(theCounters), theCounters_2_1 = theCounters_2.next(); !theCounters_2_1.done; theCounters_2_1 = theCounters_2.next()) {\n        var counter = theCounters_2_1.value;\n        lastPatternSize += counter;\n      }\n    } catch (e_2_1) {\n      e_2 = {\n        error: e_2_1\n      };\n    } finally {\n      try {\n        if (theCounters_2_1 && !theCounters_2_1.done && (_b = theCounters_2.return)) _b.call(theCounters_2);\n      } finally {\n        if (e_2) throw e_2.error;\n      }\n    }\n    // Should be at least one more black module\n    if (nextStart === end || !row.get(nextStart)) {\n      throw new NotFoundException();\n    }\n    if (this.decodeRowResult.length < 2) {\n      // false positive -- need at least 2 checksum digits\n      throw new NotFoundException();\n    }\n    this.checkChecksums(this.decodeRowResult);\n    // Remove checksum digits\n    this.decodeRowResult = this.decodeRowResult.substring(0, this.decodeRowResult.length - 2);\n    var resultString = this.decodeExtended(this.decodeRowResult);\n    var left = (start[1] + start[0]) / 2.0;\n    var right = lastStart + lastPatternSize / 2.0;\n    return new Result(resultString, null, 0, [new ResultPoint(left, rowNumber), new ResultPoint(right, rowNumber)], BarcodeFormat.CODE_93, new Date().getTime());\n  };\n  Code93Reader.prototype.findAsteriskPattern = function (row) {\n    var width = row.getSize();\n    var rowOffset = row.getNextSet(0);\n    this.counters.fill(0);\n    var theCounters = this.counters;\n    var patternStart = rowOffset;\n    var isWhite = false;\n    var patternLength = theCounters.length;\n    var counterPosition = 0;\n    for (var i = rowOffset; i < width; i++) {\n      if (row.get(i) !== isWhite) {\n        theCounters[counterPosition]++;\n      } else {\n        if (counterPosition === patternLength - 1) {\n          if (this.toPattern(theCounters) === Code93Reader.ASTERISK_ENCODING) {\n            return new Int32Array([patternStart, i]);\n          }\n          patternStart += theCounters[0] + theCounters[1];\n          theCounters.copyWithin(0, 2, 2 + counterPosition - 1);\n          theCounters[counterPosition - 1] = 0;\n          theCounters[counterPosition] = 0;\n          counterPosition--;\n        } else {\n          counterPosition++;\n        }\n        theCounters[counterPosition] = 1;\n        isWhite = !isWhite;\n      }\n    }\n    throw new NotFoundException();\n  };\n  Code93Reader.prototype.toPattern = function (counters) {\n    var e_3, _a;\n    var sum = 0;\n    try {\n      for (var counters_1 = __values(counters), counters_1_1 = counters_1.next(); !counters_1_1.done; counters_1_1 = counters_1.next()) {\n        var counter = counters_1_1.value;\n        sum += counter;\n      }\n    } catch (e_3_1) {\n      e_3 = {\n        error: e_3_1\n      };\n    } finally {\n      try {\n        if (counters_1_1 && !counters_1_1.done && (_a = counters_1.return)) _a.call(counters_1);\n      } finally {\n        if (e_3) throw e_3.error;\n      }\n    }\n    var pattern = 0;\n    var max = counters.length;\n    for (var i = 0; i < max; i++) {\n      var scaled = Math.round(counters[i] * 9.0 / sum);\n      if (scaled < 1 || scaled > 4) {\n        return -1;\n      }\n      if ((i & 0x01) === 0) {\n        for (var j = 0; j < scaled; j++) {\n          pattern = pattern << 1 | 0x01;\n        }\n      } else {\n        pattern <<= scaled;\n      }\n    }\n    return pattern;\n  };\n  Code93Reader.prototype.patternToChar = function (pattern) {\n    for (var i = 0; i < Code93Reader.CHARACTER_ENCODINGS.length; i++) {\n      if (Code93Reader.CHARACTER_ENCODINGS[i] === pattern) {\n        return Code93Reader.ALPHABET_STRING.charAt(i);\n      }\n    }\n    throw new NotFoundException();\n  };\n  Code93Reader.prototype.decodeExtended = function (encoded) {\n    var length = encoded.length;\n    var decoded = '';\n    for (var i = 0; i < length; i++) {\n      var c = encoded.charAt(i);\n      if (c >= 'a' && c <= 'd') {\n        if (i >= length - 1) {\n          throw new FormatException();\n        }\n        var next = encoded.charAt(i + 1);\n        var decodedChar = '\\0';\n        switch (c) {\n          case 'd':\n            // +A to +Z map to a to z\n            if (next >= 'A' && next <= 'Z') {\n              decodedChar = String.fromCharCode(next.charCodeAt(0) + 32);\n            } else {\n              throw new FormatException();\n            }\n            break;\n          case 'a':\n            // $A to $Z map to control codes SH to SB\n            if (next >= 'A' && next <= 'Z') {\n              decodedChar = String.fromCharCode(next.charCodeAt(0) - 64);\n            } else {\n              throw new FormatException();\n            }\n            break;\n          case 'b':\n            if (next >= 'A' && next <= 'E') {\n              // %A to %E map to control codes ESC to USep\n              decodedChar = String.fromCharCode(next.charCodeAt(0) - 38);\n            } else if (next >= 'F' && next <= 'J') {\n              // %F to %J map to ; < = > ?\n              decodedChar = String.fromCharCode(next.charCodeAt(0) - 11);\n            } else if (next >= 'K' && next <= 'O') {\n              // %K to %O map to [ \\ ] ^ _\n              decodedChar = String.fromCharCode(next.charCodeAt(0) + 16);\n            } else if (next >= 'P' && next <= 'T') {\n              // %P to %T map to { | } ~ DEL\n              decodedChar = String.fromCharCode(next.charCodeAt(0) + 43);\n            } else if (next === 'U') {\n              // %U map to NUL\n              decodedChar = '\\0';\n            } else if (next === 'V') {\n              // %V map to @\n              decodedChar = '@';\n            } else if (next === 'W') {\n              // %W map to `\n              decodedChar = '`';\n            } else if (next >= 'X' && next <= 'Z') {\n              // %X to %Z all map to DEL (127)\n              decodedChar = String.fromCharCode(127);\n            } else {\n              throw new FormatException();\n            }\n            break;\n          case 'c':\n            // /A to /O map to ! to , and /Z maps to :\n            if (next >= 'A' && next <= 'O') {\n              decodedChar = String.fromCharCode(next.charCodeAt(0) - 32);\n            } else if (next === 'Z') {\n              decodedChar = ':';\n            } else {\n              throw new FormatException();\n            }\n            break;\n        }\n        decoded += decodedChar;\n        // bump up i again since we read two characters\n        i++;\n      } else {\n        decoded += c;\n      }\n    }\n    return decoded;\n  };\n  Code93Reader.prototype.checkChecksums = function (result) {\n    var length = result.length;\n    this.checkOneChecksum(result, length - 2, 20);\n    this.checkOneChecksum(result, length - 1, 15);\n  };\n  Code93Reader.prototype.checkOneChecksum = function (result, checkPosition, weightMax) {\n    var weight = 1;\n    var total = 0;\n    for (var i = checkPosition - 1; i >= 0; i--) {\n      total += weight * Code93Reader.ALPHABET_STRING.indexOf(result.charAt(i));\n      if (++weight > weightMax) {\n        weight = 1;\n      }\n    }\n    if (result.charAt(checkPosition) !== Code93Reader.ALPHABET_STRING[total % 47]) {\n      throw new ChecksumException();\n    }\n  };\n  // Note that 'abcd' are dummy characters in place of control characters.\n  Code93Reader.ALPHABET_STRING = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ-. $/+%abcd*\";\n  /**\n   * These represent the encodings of characters, as patterns of wide and narrow bars.\n   * The 9 least-significant bits of each int correspond to the pattern of wide and narrow.\n   */\n  Code93Reader.CHARACTER_ENCODINGS = [0x114, 0x148, 0x144, 0x142, 0x128, 0x124, 0x122, 0x150, 0x112, 0x10A, 0x1A8, 0x1A4, 0x1A2, 0x194, 0x192, 0x18A, 0x168, 0x164, 0x162, 0x134, 0x11A, 0x158, 0x14C, 0x146, 0x12C, 0x116, 0x1B4, 0x1B2, 0x1AC, 0x1A6, 0x196, 0x19A, 0x16C, 0x166, 0x136, 0x13A, 0x12E, 0x1D4, 0x1D2, 0x1CA, 0x16E, 0x176, 0x1AE, 0x126, 0x1DA, 0x1D6, 0x132, 0x15E];\n  Code93Reader.ASTERISK_ENCODING = Code93Reader.CHARACTER_ENCODINGS[47];\n  return Code93Reader;\n}(OneDReader);\nexport default Code93Reader;","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}