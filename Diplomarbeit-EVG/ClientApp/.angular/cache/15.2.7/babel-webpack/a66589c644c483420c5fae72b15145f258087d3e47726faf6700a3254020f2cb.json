{"ast":null,"code":"import StringBuilder from '../../util/StringBuilder';\nimport { ALOG, FACTORS, FACTOR_SETS, LOG } from './constants';\n/**\n * Error Correction Code for ECC200.\n */\nvar ErrorCorrection = /** @class */function () {\n  function ErrorCorrection() {}\n  /**\n   * Creates the ECC200 error correction for an encoded message.\n   *\n   * @param codewords  the codewords\n   * @param symbolInfo information about the symbol to be encoded\n   * @return the codewords with interleaved error correction.\n   */\n  ErrorCorrection.encodeECC200 = function (codewords, symbolInfo) {\n    if (codewords.length !== symbolInfo.getDataCapacity()) {\n      throw new Error('The number of codewords does not match the selected symbol');\n    }\n    var sb = new StringBuilder();\n    sb.append(codewords);\n    var blockCount = symbolInfo.getInterleavedBlockCount();\n    if (blockCount === 1) {\n      var ecc = this.createECCBlock(codewords, symbolInfo.getErrorCodewords());\n      sb.append(ecc);\n    } else {\n      // sb.setLength(sb.capacity());\n      var dataSizes = [];\n      var errorSizes = [];\n      for (var i = 0; i < blockCount; i++) {\n        dataSizes[i] = symbolInfo.getDataLengthForInterleavedBlock(i + 1);\n        errorSizes[i] = symbolInfo.getErrorLengthForInterleavedBlock(i + 1);\n      }\n      for (var block = 0; block < blockCount; block++) {\n        var temp = new StringBuilder();\n        for (var d = block; d < symbolInfo.getDataCapacity(); d += blockCount) {\n          temp.append(codewords.charAt(d));\n        }\n        var ecc = this.createECCBlock(temp.toString(), errorSizes[block]);\n        var pos = 0;\n        for (var e = block; e < errorSizes[block] * blockCount; e += blockCount) {\n          sb.setCharAt(symbolInfo.getDataCapacity() + e, ecc.charAt(pos++));\n        }\n      }\n    }\n    return sb.toString();\n  };\n  ErrorCorrection.createECCBlock = function (codewords, numECWords) {\n    var table = -1;\n    for (var i = 0; i < FACTOR_SETS.length; i++) {\n      if (FACTOR_SETS[i] === numECWords) {\n        table = i;\n        break;\n      }\n    }\n    if (table < 0) {\n      throw new Error('Illegal number of error correction codewords specified: ' + numECWords);\n    }\n    var poly = FACTORS[table];\n    var ecc = [];\n    for (var i = 0; i < numECWords; i++) {\n      ecc[i] = 0;\n    }\n    for (var i = 0; i < codewords.length; i++) {\n      var m = ecc[numECWords - 1] ^ codewords.charAt(i).charCodeAt(0);\n      for (var k = numECWords - 1; k > 0; k--) {\n        if (m !== 0 && poly[k] !== 0) {\n          ecc[k] = ecc[k - 1] ^ ALOG[(LOG[m] + LOG[poly[k]]) % 255];\n        } else {\n          ecc[k] = ecc[k - 1];\n        }\n      }\n      if (m !== 0 && poly[0] !== 0) {\n        ecc[0] = ALOG[(LOG[m] + LOG[poly[0]]) % 255];\n      } else {\n        ecc[0] = 0;\n      }\n    }\n    var eccReversed = [];\n    for (var i = 0; i < numECWords; i++) {\n      eccReversed[i] = ecc[numECWords - i - 1];\n    }\n    return eccReversed.map(function (c) {\n      return String.fromCharCode(c);\n    }).join('');\n  };\n  return ErrorCorrection;\n}();\nexport default ErrorCorrection;","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}