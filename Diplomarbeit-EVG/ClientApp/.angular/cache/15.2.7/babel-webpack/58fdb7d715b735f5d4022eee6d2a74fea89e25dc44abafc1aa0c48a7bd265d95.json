{"ast":null,"code":"var __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n    return extendStatics(d, b);\n  };\n  return function (d, b) {\n    extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\nvar __values = this && this.__values || function (o) {\n  var s = typeof Symbol === \"function\" && Symbol.iterator,\n    m = s && o[s],\n    i = 0;\n  if (m) return m.call(o);\n  if (o && typeof o.length === \"number\") return {\n    next: function () {\n      if (o && i >= o.length) o = void 0;\n      return {\n        value: o && o[i++],\n        done: !o\n      };\n    }\n  };\n  throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n    r,\n    ar = [],\n    e;\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n  return ar;\n};\nvar __spread = this && this.__spread || function () {\n  for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));\n  return ar;\n};\nimport { MACRO_05_HEADER, MACRO_06_HEADER, MACRO_TRAILER } from './constants';\nimport HighLevelEncoder from './HighLevelEncoder';\nimport { MinimalECIInput } from '../../common/MinimalECIInput';\nimport Integer from '../../util/Integer';\nvar Mode = /*#__PURE__*/(() => {\n  (function (Mode) {\n    Mode[Mode[\"ASCII\"] = 0] = \"ASCII\";\n    Mode[Mode[\"C40\"] = 1] = \"C40\";\n    Mode[Mode[\"TEXT\"] = 2] = \"TEXT\";\n    Mode[Mode[\"X12\"] = 3] = \"X12\";\n    Mode[Mode[\"EDF\"] = 4] = \"EDF\";\n    Mode[Mode[\"B256\"] = 5] = \"B256\";\n  })(Mode || (Mode = {}));\n  return Mode;\n})();\nvar C40_SHIFT2_CHARS = ['!', '\"', '#', '$', '%', '&', \"'\", '(', ')', '*', '+', ',', '-', '.', '/', ':', ';', '<', '=', '>', '?', '@', '[', '\\\\', ']', '^', '_'];\nvar MinimalEncoder = /** @class */function () {\n  function MinimalEncoder() {}\n  MinimalEncoder.isExtendedASCII = function (ch, fnc1) {\n    return ch !== fnc1 && ch >= 128 && ch <= 255;\n  };\n  MinimalEncoder.isInC40Shift1Set = function (ch) {\n    return ch <= 31;\n  };\n  MinimalEncoder.isInC40Shift2Set = function (ch, fnc1) {\n    var e_1, _a;\n    try {\n      for (var C40_SHIFT2_CHARS_1 = __values(C40_SHIFT2_CHARS), C40_SHIFT2_CHARS_1_1 = C40_SHIFT2_CHARS_1.next(); !C40_SHIFT2_CHARS_1_1.done; C40_SHIFT2_CHARS_1_1 = C40_SHIFT2_CHARS_1.next()) {\n        var c40Shift2Char = C40_SHIFT2_CHARS_1_1.value;\n        if (c40Shift2Char.charCodeAt(0) === ch) {\n          return true;\n        }\n      }\n    } catch (e_1_1) {\n      e_1 = {\n        error: e_1_1\n      };\n    } finally {\n      try {\n        if (C40_SHIFT2_CHARS_1_1 && !C40_SHIFT2_CHARS_1_1.done && (_a = C40_SHIFT2_CHARS_1.return)) _a.call(C40_SHIFT2_CHARS_1);\n      } finally {\n        if (e_1) throw e_1.error;\n      }\n    }\n    return ch === fnc1;\n  };\n  MinimalEncoder.isInTextShift1Set = function (ch) {\n    return this.isInC40Shift1Set(ch);\n  };\n  MinimalEncoder.isInTextShift2Set = function (ch, fnc1) {\n    return this.isInC40Shift2Set(ch, fnc1);\n  };\n  /**\n   * Performs message encoding of a DataMatrix message\n   *\n   * @param msg the message\n   * @param priorityCharset The preferred {@link Charset}. When the value of the argument is null, the algorithm\n   *   chooses charsets that leads to a minimal representation. Otherwise the algorithm will use the priority\n   *   charset to encode any character in the input that can be encoded by it if the charset is among the\n   *   supported charsets.\n   * @param fnc1 denotes the character in the input that represents the FNC1 character or -1 if this is not a GS1\n   *   bar code. If the value is not -1 then a FNC1 is also prepended.\n   * @param shape requested shape.\n   * @return the encoded message (the char values range from 0 to 255)\n   */\n  MinimalEncoder.encodeHighLevel = function (msg, priorityCharset, fnc1, shape) {\n    if (priorityCharset === void 0) {\n      priorityCharset = null;\n    }\n    if (fnc1 === void 0) {\n      fnc1 = -1;\n    }\n    if (shape === void 0) {\n      shape = 0 /* FORCE_NONE */;\n    }\n    var macroId = 0;\n    if (msg.startsWith(MACRO_05_HEADER) && msg.endsWith(MACRO_TRAILER)) {\n      macroId = 5;\n      msg = msg.substring(MACRO_05_HEADER.length, msg.length - 2);\n    } else if (msg.startsWith(MACRO_06_HEADER) && msg.endsWith(MACRO_TRAILER)) {\n      macroId = 6;\n      msg = msg.substring(MACRO_06_HEADER.length, msg.length - 2);\n    }\n    return decodeURIComponent(escape(String.fromCharCode.apply(String, __spread(this.encode(msg, priorityCharset, fnc1, shape, macroId)))));\n  };\n  /**\n   * Encodes input minimally and returns an array of the codewords\n   *\n   * @param input The string to encode\n   * @param priorityCharset The preferred {@link Charset}. When the value of the argument is null, the algorithm\n   *   chooses charsets that leads to a minimal representation. Otherwise the algorithm will use the priority\n   *   charset to encode any character in the input that can be encoded by it if the charset is among the\n   *   supported charsets.\n   * @param fnc1 denotes the character in the input that represents the FNC1 character or -1 if this is not a GS1\n   *   bar code. If the value is not -1 then a FNC1 is also prepended.\n   * @param shape requested shape.\n   * @param macroId Prepends the specified macro function in case that a value of 5 or 6 is specified.\n   * @return An array of bytes representing the codewords of a minimal encoding.\n   */\n  MinimalEncoder.encode = function (input, priorityCharset, fnc1, shape, macroId) {\n    return this.encodeMinimally(new Input(input, priorityCharset, fnc1, shape, macroId)).getBytes();\n  };\n  MinimalEncoder.addEdge = function (edges, edge) {\n    var vertexIndex = edge.fromPosition + edge.characterLength;\n    if (edges[vertexIndex][edge.getEndMode()] === null || edges[vertexIndex][edge.getEndMode()].cachedTotalSize > edge.cachedTotalSize) {\n      edges[vertexIndex][edge.getEndMode()] = edge;\n    }\n  };\n  /** @return the number of words in which the string starting at from can be encoded in c40 or text mode.\n   *  The number of characters encoded is returned in characterLength.\n   *  The number of characters encoded is also minimal in the sense that the algorithm stops as soon\n   *  as a character encoding fills a C40 word competely (three C40 values). An exception is at the\n   *  end of the string where two C40 values are allowed (according to the spec the third c40 value\n   *  is filled  with 0 (Shift 1) in this case).\n   */\n  MinimalEncoder.getNumberOfC40Words = function (input, from, c40, characterLength) {\n    var thirdsCount = 0;\n    for (var i = from; i < input.length(); i++) {\n      if (input.isECI(i)) {\n        characterLength[0] = 0;\n        return 0;\n      }\n      var ci = input.charAt(i);\n      if (c40 && HighLevelEncoder.isNativeC40(ci) || !c40 && HighLevelEncoder.isNativeText(ci)) {\n        thirdsCount++; // native\n      } else if (!MinimalEncoder.isExtendedASCII(ci, input.getFNC1Character())) {\n        thirdsCount += 2; // shift\n      } else {\n        var asciiValue = ci & 0xff;\n        if (asciiValue >= 128 && (c40 && HighLevelEncoder.isNativeC40(asciiValue - 128) || !c40 && HighLevelEncoder.isNativeText(asciiValue - 128))) {\n          thirdsCount += 3; // shift, Upper shift\n        } else {\n          thirdsCount += 4; // shift, Upper shift, shift\n        }\n      }\n\n      if (thirdsCount % 3 === 0 || (thirdsCount - 2) % 3 === 0 && i + 1 === input.length()) {\n        characterLength[0] = i - from + 1;\n        return Math.ceil(thirdsCount / 3.0);\n      }\n    }\n    characterLength[0] = 0;\n    return 0;\n  };\n  MinimalEncoder.addEdges = function (input, edges, from, previous) {\n    var e_2, _a;\n    if (input.isECI(from)) {\n      this.addEdge(edges, new Edge(input, Mode.ASCII, from, 1, previous));\n      return;\n    }\n    var ch = input.charAt(from);\n    if (previous === null || previous.getEndMode() !== Mode.EDF) {\n      // not possible to unlatch a full EDF edge to something\n      // else\n      if (HighLevelEncoder.isDigit(ch) && input.haveNCharacters(from, 2) && HighLevelEncoder.isDigit(input.charAt(from + 1))) {\n        // two digits ASCII encoded\n        this.addEdge(edges, new Edge(input, Mode.ASCII, from, 2, previous));\n      } else {\n        // one ASCII encoded character or an extended character via Upper Shift\n        this.addEdge(edges, new Edge(input, Mode.ASCII, from, 1, previous));\n      }\n      var modes = [Mode.C40, Mode.TEXT];\n      try {\n        for (var modes_1 = __values(modes), modes_1_1 = modes_1.next(); !modes_1_1.done; modes_1_1 = modes_1.next()) {\n          var mode = modes_1_1.value;\n          var characterLength = [];\n          if (MinimalEncoder.getNumberOfC40Words(input, from, mode === Mode.C40, characterLength) > 0) {\n            this.addEdge(edges, new Edge(input, mode, from, characterLength[0], previous));\n          }\n        }\n      } catch (e_2_1) {\n        e_2 = {\n          error: e_2_1\n        };\n      } finally {\n        try {\n          if (modes_1_1 && !modes_1_1.done && (_a = modes_1.return)) _a.call(modes_1);\n        } finally {\n          if (e_2) throw e_2.error;\n        }\n      }\n      if (input.haveNCharacters(from, 3) && HighLevelEncoder.isNativeX12(input.charAt(from)) && HighLevelEncoder.isNativeX12(input.charAt(from + 1)) && HighLevelEncoder.isNativeX12(input.charAt(from + 2))) {\n        this.addEdge(edges, new Edge(input, Mode.X12, from, 3, previous));\n      }\n      this.addEdge(edges, new Edge(input, Mode.B256, from, 1, previous));\n    }\n    // We create 4 EDF edges,  with 1, 2 3 or 4 characters length. The fourth normally doesn't have a latch to ASCII\n    // unless it is 2 characters away from the end of the input.\n    var i;\n    for (i = 0; i < 3; i++) {\n      var pos = from + i;\n      if (input.haveNCharacters(pos, 1) && HighLevelEncoder.isNativeEDIFACT(input.charAt(pos))) {\n        this.addEdge(edges, new Edge(input, Mode.EDF, from, i + 1, previous));\n      } else {\n        break;\n      }\n    }\n    if (i === 3 && input.haveNCharacters(from, 4) && HighLevelEncoder.isNativeEDIFACT(input.charAt(from + 3))) {\n      this.addEdge(edges, new Edge(input, Mode.EDF, from, 4, previous));\n    }\n  };\n  MinimalEncoder.encodeMinimally = function (input) {\n    /* The minimal encoding is computed by Dijkstra. The acyclic graph is modeled as follows:\n     * A vertex represents a combination of a position in the input and an encoding mode where position 0\n     * denotes the position left of the first character, 1 the position left of the second character and so on.\n     * Likewise the end vertices are located after the last character at position input.length().\n     * For any position there might be up to six vertices, one for each of the encoding types ASCII, C40, TEXT, X12,\n     * EDF and B256.\n     *\n     * As an example consider the input string \"ABC123\" then at position 0 there is only one vertex with the default\n     * ASCII encodation. At position 3 there might be vertices for the types ASCII, C40, X12, EDF and B256.\n     *\n     * An edge leading to such a vertex encodes one or more of the characters left of the position that the vertex\n     * represents. It encodes the characters in the encoding mode of the vertex that it ends on. In other words,\n     * all edges leading to a particular vertex encode the same characters (the length of the suffix can vary) using the same\n     * encoding mode.\n     * As an example consider the input string \"ABC123\" and the vertex (4,EDF). Possible edges leading to this vertex\n     * are:\n     *   (0,ASCII)  --EDF(ABC1)--> (4,EDF)\n     *   (1,ASCII)  --EDF(BC1)-->  (4,EDF)\n     *   (1,B256)   --EDF(BC1)-->  (4,EDF)\n     *   (1,EDF)    --EDF(BC1)-->  (4,EDF)\n     *   (2,ASCII)  --EDF(C1)-->   (4,EDF)\n     *   (2,B256)   --EDF(C1)-->   (4,EDF)\n     *   (2,EDF)    --EDF(C1)-->   (4,EDF)\n     *   (3,ASCII)  --EDF(1)-->    (4,EDF)\n     *   (3,B256)   --EDF(1)-->    (4,EDF)\n     *   (3,EDF)    --EDF(1)-->    (4,EDF)\n     *   (3,C40)    --EDF(1)-->    (4,EDF)\n     *   (3,X12)    --EDF(1)-->    (4,EDF)\n     *\n     * The edges leading to a vertex are stored in such a way that there is a fast way to enumerate the edges ending\n     * on a particular vertex.\n     *\n     * The algorithm processes the vertices in order of their position thereby performing the following:\n     *\n     * For every vertex at position i the algorithm enumerates the edges ending on the vertex and removes all but the\n     * shortest from that list.\n     * Then it processes the vertices for the position i+1. If i+1 == input.length() then the algorithm ends\n     * and chooses the the edge with the smallest size from any of the edges leading to vertices at this position.\n     * Otherwise the algorithm computes all possible outgoing edges for the vertices at the position i+1\n     *\n     * Examples:\n     * The process is illustrated by showing the graph (edges) after each iteration from left to right over the input:\n     * An edge is drawn as follows \"(\" + fromVertex + \") -- \" + encodingMode + \"(\" + encodedInput + \") (\" +\n     * accumulatedSize + \") --> (\" + toVertex + \")\"\n     *\n     * Example 1 encoding the string \"ABCDEFG\":\n     *\n     *\n     * Situation after adding edges to the start vertex (0,ASCII)\n     * (0,ASCII) ASCII(A) (1) --> (1,ASCII)\n     * (0,ASCII) B256(A) (3) --> (1,B256)\n     * (0,ASCII) EDF(AB) (4) --> (2,EDF)\n     * (0,ASCII) C40(ABC) (3) --> (3,C40)\n     * (0,ASCII) TEXT(ABC) (5) --> (3,TEXT)\n     * (0,ASCII) X12(ABC) (3) --> (3,X12)\n     * (0,ASCII) EDF(ABC) (4) --> (3,EDF)\n     * (0,ASCII) EDF(ABCD) (4) --> (4,EDF)\n     *\n     * Situation after adding edges to vertices at position 1\n     * (0,ASCII) ASCII(A) (1) --> (1,ASCII)\n     * (0,ASCII) B256(A) (3) --> (1,B256)\n     * (0,ASCII) EDF(AB) (4) --> (2,EDF)\n     * (0,ASCII) C40(ABC) (3) --> (3,C40)\n     * (0,ASCII) TEXT(ABC) (5) --> (3,TEXT)\n     * (0,ASCII) X12(ABC) (3) --> (3,X12)\n     * (0,ASCII) EDF(ABC) (4) --> (3,EDF)\n     * (0,ASCII) EDF(ABCD) (4) --> (4,EDF)\n     * (0,ASCII) ASCII(A) (1) --> (1,ASCII) ASCII(B) (2) --> (2,ASCII)\n     * (0,ASCII) ASCII(A) (1) --> (1,ASCII) B256(B) (4) --> (2,B256)\n     * (0,ASCII) ASCII(A) (1) --> (1,ASCII) EDF(BC) (5) --> (3,EDF)\n     * (0,ASCII) ASCII(A) (1) --> (1,ASCII) C40(BCD) (4) --> (4,C40)\n     * (0,ASCII) ASCII(A) (1) --> (1,ASCII) TEXT(BCD) (6) --> (4,TEXT)\n     * (0,ASCII) ASCII(A) (1) --> (1,ASCII) X12(BCD) (4) --> (4,X12)\n     * (0,ASCII) ASCII(A) (1) --> (1,ASCII) EDF(BCD) (5) --> (4,EDF)\n     * (0,ASCII) ASCII(A) (1) --> (1,ASCII) EDF(BCDE) (5) --> (5,EDF)\n     * (0,ASCII) B256(A) (3) --> (1,B256) ASCII(B) (4) --> (2,ASCII)\n     * (0,ASCII) B256(A) (3) --> (1,B256) B256(B) (3) --> (2,B256)\n     * (0,ASCII) B256(A) (3) --> (1,B256) EDF(BC) (6) --> (3,EDF)\n     * (0,ASCII) B256(A) (3) --> (1,B256) C40(BCD) (5) --> (4,C40)\n     * (0,ASCII) B256(A) (3) --> (1,B256) TEXT(BCD) (7) --> (4,TEXT)\n     * (0,ASCII) B256(A) (3) --> (1,B256) X12(BCD) (5) --> (4,X12)\n     * (0,ASCII) B256(A) (3) --> (1,B256) EDF(BCD) (6) --> (4,EDF)\n     * (0,ASCII) B256(A) (3) --> (1,B256) EDF(BCDE) (6) --> (5,EDF)\n     *\n     * Edge \"(1,ASCII) ASCII(B) (2) --> (2,ASCII)\" is minimal for the vertex (2,ASCII) so that edge \"(1,B256) ASCII(B) (4) --> (2,ASCII)\" is removed.\n     * Edge \"(1,B256) B256(B) (3) --> (2,B256)\" is minimal for the vertext (2,B256) so that the edge \"(1,ASCII) B256(B) (4) --> (2,B256)\" is removed.\n     *\n     * Situation after adding edges to vertices at position 2\n     * (0,ASCII) ASCII(A) (1) --> (1,ASCII)\n     * (0,ASCII) B256(A) (3) --> (1,B256)\n     * (0,ASCII) EDF(AB) (4) --> (2,EDF)\n     * (0,ASCII) C40(ABC) (3) --> (3,C40)\n     * (0,ASCII) TEXT(ABC) (5) --> (3,TEXT)\n     * (0,ASCII) X12(ABC) (3) --> (3,X12)\n     * (0,ASCII) EDF(ABC) (4) --> (3,EDF)\n     * (0,ASCII) EDF(ABCD) (4) --> (4,EDF)\n     * (0,ASCII) ASCII(A) (1) --> (1,ASCII) ASCII(B) (2) --> (2,ASCII)\n     * (0,ASCII) ASCII(A) (1) --> (1,ASCII) EDF(BC) (5) --> (3,EDF)\n     * (0,ASCII) ASCII(A) (1) --> (1,ASCII) C40(BCD) (4) --> (4,C40)\n     * (0,ASCII) ASCII(A) (1) --> (1,ASCII) TEXT(BCD) (6) --> (4,TEXT)\n     * (0,ASCII) ASCII(A) (1) --> (1,ASCII) X12(BCD) (4) --> (4,X12)\n     * (0,ASCII) ASCII(A) (1) --> (1,ASCII) EDF(BCD) (5) --> (4,EDF)\n     * (0,ASCII) ASCII(A) (1) --> (1,ASCII) EDF(BCDE) (5) --> (5,EDF)\n     * (0,ASCII) B256(A) (3) --> (1,B256) B256(B) (3) --> (2,B256)\n     * (0,ASCII) B256(A) (3) --> (1,B256) EDF(BC) (6) --> (3,EDF)\n     * (0,ASCII) B256(A) (3) --> (1,B256) C40(BCD) (5) --> (4,C40)\n     * (0,ASCII) B256(A) (3) --> (1,B256) TEXT(BCD) (7) --> (4,TEXT)\n     * (0,ASCII) B256(A) (3) --> (1,B256) X12(BCD) (5) --> (4,X12)\n     * (0,ASCII) B256(A) (3) --> (1,B256) EDF(BCD) (6) --> (4,EDF)\n     * (0,ASCII) B256(A) (3) --> (1,B256) EDF(BCDE) (6) --> (5,EDF)\n     * (0,ASCII) EDF(AB) (4) --> (2,EDF) ASCII(C) (5) --> (3,ASCII)\n     * (0,ASCII) EDF(AB) (4) --> (2,EDF) B256(C) (6) --> (3,B256)\n     * (0,ASCII) EDF(AB) (4) --> (2,EDF) EDF(CD) (7) --> (4,EDF)\n     * (0,ASCII) EDF(AB) (4) --> (2,EDF) C40(CDE) (6) --> (5,C40)\n     * (0,ASCII) EDF(AB) (4) --> (2,EDF) TEXT(CDE) (8) --> (5,TEXT)\n     * (0,ASCII) EDF(AB) (4) --> (2,EDF) X12(CDE) (6) --> (5,X12)\n     * (0,ASCII) EDF(AB) (4) --> (2,EDF) EDF(CDE) (7) --> (5,EDF)\n     * (0,ASCII) EDF(AB) (4) --> (2,EDF) EDF(CDEF) (7) --> (6,EDF)\n     * (0,ASCII) ASCII(A) (1) --> (1,ASCII) ASCII(B) (2) --> (2,ASCII) ASCII(C) (3) --> (3,ASCII)\n     * (0,ASCII) ASCII(A) (1) --> (1,ASCII) ASCII(B) (2) --> (2,ASCII) B256(C) (5) --> (3,B256)\n     * (0,ASCII) ASCII(A) (1) --> (1,ASCII) ASCII(B) (2) --> (2,ASCII) EDF(CD) (6) --> (4,EDF)\n     * (0,ASCII) ASCII(A) (1) --> (1,ASCII) ASCII(B) (2) --> (2,ASCII) C40(CDE) (5) --> (5,C40)\n     * (0,ASCII) ASCII(A) (1) --> (1,ASCII) ASCII(B) (2) --> (2,ASCII) TEXT(CDE) (7) --> (5,TEXT)\n     * (0,ASCII) ASCII(A) (1) --> (1,ASCII) ASCII(B) (2) --> (2,ASCII) X12(CDE) (5) --> (5,X12)\n     * (0,ASCII) ASCII(A) (1) --> (1,ASCII) ASCII(B) (2) --> (2,ASCII) EDF(CDE) (6) --> (5,EDF)\n     * (0,ASCII) ASCII(A) (1) --> (1,ASCII) ASCII(B) (2) --> (2,ASCII) EDF(CDEF) (6) --> (6,EDF)\n     * (0,ASCII) B256(A) (3) --> (1,B256) B256(B) (3) --> (2,B256) ASCII(C) (4) --> (3,ASCII)\n     * (0,ASCII) B256(A) (3) --> (1,B256) B256(B) (3) --> (2,B256) B256(C) (4) --> (3,B256)\n     * (0,ASCII) B256(A) (3) --> (1,B256) B256(B) (3) --> (2,B256) EDF(CD) (6) --> (4,EDF)\n     * (0,ASCII) B256(A) (3) --> (1,B256) B256(B) (3) --> (2,B256) C40(CDE) (5) --> (5,C40)\n     * (0,ASCII) B256(A) (3) --> (1,B256) B256(B) (3) --> (2,B256) TEXT(CDE) (7) --> (5,TEXT)\n     * (0,ASCII) B256(A) (3) --> (1,B256) B256(B) (3) --> (2,B256) X12(CDE) (5) --> (5,X12)\n     * (0,ASCII) B256(A) (3) --> (1,B256) B256(B) (3) --> (2,B256) EDF(CDE) (6) --> (5,EDF)\n     * (0,ASCII) B256(A) (3) --> (1,B256) B256(B) (3) --> (2,B256) EDF(CDEF) (6) --> (6,EDF)\n     *\n     * Edge \"(2,ASCII) ASCII(C) (3) --> (3,ASCII)\" is minimal for the vertex (3,ASCII) so that edges \"(2,EDF) ASCII(C) (5) --> (3,ASCII)\"\n     * and \"(2,B256) ASCII(C) (4) --> (3,ASCII)\" can be removed.\n     * Edge \"(0,ASCII) EDF(ABC) (4) --> (3,EDF)\" is minimal for the vertex (3,EDF) so that edges \"(1,ASCII) EDF(BC) (5) --> (3,EDF)\"\n     * and \"(1,B256) EDF(BC) (6) --> (3,EDF)\" can be removed.\n     * Edge \"(2,B256) B256(C) (4) --> (3,B256)\" is minimal for the vertex (3,B256) so that edges \"(2,ASCII) B256(C) (5) --> (3,B256)\"\n     * and \"(2,EDF) B256(C) (6) --> (3,B256)\" can be removed.\n     *\n     * This continues for vertices 3 thru 7\n     *\n     * Situation after adding edges to vertices at position 7\n     * (0,ASCII) ASCII(A) (1) --> (1,ASCII)\n     * (0,ASCII) B256(A) (3) --> (1,B256)\n     * (0,ASCII) EDF(AB) (4) --> (2,EDF)\n     * (0,ASCII) C40(ABC) (3) --> (3,C40)\n     * (0,ASCII) TEXT(ABC) (5) --> (3,TEXT)\n     * (0,ASCII) X12(ABC) (3) --> (3,X12)\n     * (0,ASCII) EDF(ABC) (4) --> (3,EDF)\n     * (0,ASCII) EDF(ABCD) (4) --> (4,EDF)\n     * (0,ASCII) ASCII(A) (1) --> (1,ASCII) ASCII(B) (2) --> (2,ASCII)\n     * (0,ASCII) ASCII(A) (1) --> (1,ASCII) C40(BCD) (4) --> (4,C40)\n     * (0,ASCII) ASCII(A) (1) --> (1,ASCII) TEXT(BCD) (6) --> (4,TEXT)\n     * (0,ASCII) ASCII(A) (1) --> (1,ASCII) X12(BCD) (4) --> (4,X12)\n     * (0,ASCII) ASCII(A) (1) --> (1,ASCII) EDF(BCDE) (5) --> (5,EDF)\n     * (0,ASCII) B256(A) (3) --> (1,B256) B256(B) (3) --> (2,B256)\n     * (0,ASCII) C40(ABC) (3) --> (3,C40) C40(DEF) (5) --> (6,C40)\n     * (0,ASCII) X12(ABC) (3) --> (3,X12) X12(DEF) (5) --> (6,X12)\n     * (0,ASCII) ASCII(A) (1) --> (1,ASCII) ASCII(B) (2) --> (2,ASCII) ASCII(C) (3) --> (3,ASCII)\n     * (0,ASCII) ASCII(A) (1) --> (1,ASCII) ASCII(B) (2) --> (2,ASCII) C40(CDE) (5) --> (5,C40)\n     * (0,ASCII) ASCII(A) (1) --> (1,ASCII) ASCII(B) (2) --> (2,ASCII) TEXT(CDE) (7) --> (5,TEXT)\n     * (0,ASCII) ASCII(A) (1) --> (1,ASCII) ASCII(B) (2) --> (2,ASCII) X12(CDE) (5) --> (5,X12)\n     * (0,ASCII) ASCII(A) (1) --> (1,ASCII) ASCII(B) (2) --> (2,ASCII) EDF(CDEF) (6) --> (6,EDF)\n     * (0,ASCII) ASCII(A) (1) --> (1,ASCII) C40(BCD) (4) --> (4,C40) C40(EFG) (6) --> (7,C40)    //Solution 1\n     * (0,ASCII) ASCII(A) (1) --> (1,ASCII) X12(BCD) (4) --> (4,X12) X12(EFG) (6) --> (7,X12)    //Solution 2\n     * (0,ASCII) B256(A) (3) --> (1,B256) B256(B) (3) --> (2,B256) B256(C) (4) --> (3,B256)\n     * (0,ASCII) ASCII(A) (1) --> (1,ASCII) ASCII(B) (2) --> (2,ASCII) ASCII(C) (3) --> (3,ASCII) ASCII(D) (4) --> (4,ASCII)\n     * (0,ASCII) ASCII(A) (1) --> (1,ASCII) ASCII(B) (2) --> (2,ASCII) ASCII(C) (3) --> (3,ASCII) TEXT(DEF) (8) --> (6,TEXT)\n     * (0,ASCII) ASCII(A) (1) --> (1,ASCII) ASCII(B) (2) --> (2,ASCII) ASCII(C) (3) --> (3,ASCII) EDF(DEFG) (7) --> (7,EDF)\n     * (0,ASCII) B256(A) (3) --> (1,B256) B256(B) (3) --> (2,B256) B256(C) (4) --> (3,B256) B256(D) (5) --> (4,B256)\n     * (0,ASCII) ASCII(A) (1) --> (1,ASCII) ASCII(B) (2) --> (2,ASCII) ASCII(C) (3) --> (3,ASCII) ASCII(D) (4) --> (4,ASCII) ASCII(E) (5) --> (5,ASCII)\n     * (0,ASCII) ASCII(A) (1) --> (1,ASCII) ASCII(B) (2) --> (2,ASCII) ASCII(C) (3) --> (3,ASCII) ASCII(D) (4) --> (4,ASCII) TEXT(EFG) (9) --> (7,TEXT)\n     * (0,ASCII) B256(A) (3) --> (1,B256) B256(B) (3) --> (2,B256) B256(C) (4) --> (3,B256) B256(D) (5) --> (4,B256) B256(E) (6) --> (5,B256)\n     * (0,ASCII) ASCII(A) (1) --> (1,ASCII) ASCII(B) (2) --> (2,ASCII) ASCII(C) (3) --> (3,ASCII) ASCII(D) (4) --> (4,ASCII) ASCII(E) (5) --> (5,ASCII) ASCII(F) (6) --> (6,ASCII)\n     * (0,ASCII) B256(A) (3) --> (1,B256) B256(B) (3) --> (2,B256) B256(C) (4) --> (3,B256) B256(D) (5) --> (4,B256) B256(E) (6) --> (5,B256) B256(F) (7) --> (6,B256)\n     * (0,ASCII) ASCII(A) (1) --> (1,ASCII) ASCII(B) (2) --> (2,ASCII) ASCII(C) (3) --> (3,ASCII) ASCII(D) (4) --> (4,ASCII) ASCII(E) (5) --> (5,ASCII) ASCII(F) (6) --> (6,ASCII) ASCII(G) (7) --> (7,ASCII)\n     * (0,ASCII) B256(A) (3) --> (1,B256) B256(B) (3) --> (2,B256) B256(C) (4) --> (3,B256) B256(D) (5) --> (4,B256) B256(E) (6) --> (5,B256) B256(F) (7) --> (6,B256) B256(G) (8) --> (7,B256)\n     *\n     * Hence a minimal encoding of \"ABCDEFG\" is either ASCII(A),C40(BCDEFG) or ASCII(A), X12(BCDEFG) with a size of 5 bytes.\n     */\n    var inputLength = input.length();\n    // Array that represents vertices. There is a vertex for every character and mode.\n    // The last dimension in the array below encodes the 6 modes ASCII, C40, TEXT, X12, EDF and B256\n    var edges = Array(inputLength + 1).fill(null).map(function () {\n      return Array(6).fill(0);\n    });\n    this.addEdges(input, edges, 0, null);\n    for (var i = 1; i <= inputLength; i++) {\n      for (var j = 0; j < 6; j++) {\n        if (edges[i][j] !== null && i < inputLength) {\n          this.addEdges(input, edges, i, edges[i][j]);\n        }\n      }\n      // optimize memory by removing edges that have been passed.\n      for (var j = 0; j < 6; j++) {\n        edges[i - 1][j] = null;\n      }\n    }\n    var minimalJ = -1;\n    var minimalSize = Integer.MAX_VALUE;\n    for (var j = 0; j < 6; j++) {\n      if (edges[inputLength][j] !== null) {\n        var edge = edges[inputLength][j];\n        var size = j >= 1 && j <= 3 ? edge.cachedTotalSize + 1 : edge.cachedTotalSize; // C40, TEXT and X12 need an\n        // extra unlatch at the end\n        if (size < minimalSize) {\n          minimalSize = size;\n          minimalJ = j;\n        }\n      }\n    }\n    if (minimalJ < 0) {\n      throw new Error('Failed to encode \"' + input + '\"');\n    }\n    return new Result(edges[inputLength][minimalJ]);\n  };\n  return MinimalEncoder;\n}();\nexport { MinimalEncoder };\nvar Result = /** @class */function () {\n  function Result(solution) {\n    var input = solution.input;\n    var size = 0;\n    var bytesAL = [];\n    var randomizePostfixLength = [];\n    var randomizeLengths = [];\n    if ((solution.mode === Mode.C40 || solution.mode === Mode.TEXT || solution.mode === Mode.X12) && solution.getEndMode() !== Mode.ASCII) {\n      size += this.prepend(Edge.getBytes(254), bytesAL);\n    }\n    var current = solution;\n    while (current !== null) {\n      size += this.prepend(current.getDataBytes(), bytesAL);\n      if (current.previous === null || current.getPreviousStartMode() !== current.getMode()) {\n        if (current.getMode() === Mode.B256) {\n          if (size <= 249) {\n            bytesAL.unshift(size);\n            size++;\n          } else {\n            bytesAL.unshift(size % 250);\n            bytesAL.unshift(size / 250 + 249);\n            size += 2;\n          }\n          randomizePostfixLength.push(bytesAL.length);\n          randomizeLengths.push(size);\n        }\n        this.prepend(current.getLatchBytes(), bytesAL);\n        size = 0;\n      }\n      current = current.previous;\n    }\n    if (input.getMacroId() === 5) {\n      size += this.prepend(Edge.getBytes(236), bytesAL);\n    } else if (input.getMacroId() === 6) {\n      size += this.prepend(Edge.getBytes(237), bytesAL);\n    }\n    if (input.getFNC1Character() > 0) {\n      size += this.prepend(Edge.getBytes(232), bytesAL);\n    }\n    for (var i = 0; i < randomizePostfixLength.length; i++) {\n      this.applyRandomPattern(bytesAL, bytesAL.length - randomizePostfixLength[i], randomizeLengths[i]);\n    }\n    // add padding\n    var capacity = solution.getMinSymbolSize(bytesAL.length);\n    if (bytesAL.length < capacity) {\n      bytesAL.push(129);\n    }\n    while (bytesAL.length < capacity) {\n      bytesAL.push(this.randomize253State(bytesAL.length + 1));\n    }\n    this.bytes = new Uint8Array(bytesAL.length);\n    for (var i = 0; i < this.bytes.length; i++) {\n      this.bytes[i] = bytesAL[i];\n    }\n  }\n  Result.prototype.prepend = function (bytes, into) {\n    for (var i = bytes.length - 1; i >= 0; i--) {\n      into.unshift(bytes[i]);\n    }\n    return bytes.length;\n  };\n  Result.prototype.randomize253State = function (codewordPosition) {\n    var pseudoRandom = 149 * codewordPosition % 253 + 1;\n    var tempVariable = 129 + pseudoRandom;\n    return tempVariable <= 254 ? tempVariable : tempVariable - 254;\n  };\n  Result.prototype.applyRandomPattern = function (bytesAL, startPosition, length) {\n    for (var i = 0; i < length; i++) {\n      // See \"B.1 253-state algorithm\n      var Pad_codeword_position = startPosition + i;\n      var Pad_codeword_value = bytesAL[Pad_codeword_position] & 0xff;\n      var pseudo_random_number = 149 * (Pad_codeword_position + 1) % 255 + 1;\n      var temp_variable = Pad_codeword_value + pseudo_random_number;\n      bytesAL[Pad_codeword_position] = temp_variable <= 255 ? temp_variable : temp_variable - 256;\n    }\n  };\n  Result.prototype.getBytes = function () {\n    return this.bytes;\n  };\n  return Result;\n}();\nvar Edge = /** @class */function () {\n  function Edge(input, mode, fromPosition, characterLength, previous) {\n    this.input = input;\n    this.mode = mode;\n    this.fromPosition = fromPosition;\n    this.characterLength = characterLength;\n    this.previous = previous;\n    this.allCodewordCapacities = [3, 5, 8, 10, 12, 16, 18, 22, 30, 32, 36, 44, 49, 62, 86, 114, 144, 174, 204, 280, 368, 456, 576, 696, 816, 1050, 1304, 1558];\n    this.squareCodewordCapacities = [3, 5, 8, 12, 18, 22, 30, 36, 44, 62, 86, 114, 144, 174, 204, 280, 368, 456, 576, 696, 816, 1050, 1304, 1558];\n    this.rectangularCodewordCapacities = [5, 10, 16, 33, 32, 49];\n    if (!(fromPosition + characterLength <= input.length())) {\n      throw new Error('Invalid edge');\n    }\n    var size = previous !== null ? previous.cachedTotalSize : 0;\n    var previousMode = this.getPreviousMode();\n    /*\n     * Switching modes\n     * ASCII -> C40: latch 230\n     * ASCII -> TEXT: latch 239\n     * ASCII -> X12: latch 238\n     * ASCII -> EDF: latch 240\n     * ASCII -> B256: latch 231\n     * C40 -> ASCII: word(c1,c2,c3), 254\n     * TEXT -> ASCII: word(c1,c2,c3), 254\n     * X12 -> ASCII: word(c1,c2,c3), 254\n     * EDIFACT -> ASCII: Unlatch character,0,0,0 or c1,Unlatch character,0,0 or c1,c2,Unlatch character,0 or\n     * c1,c2,c3,Unlatch character\n     * B256 -> ASCII: without latch after n bytes\n     */\n    switch (mode) {\n      case Mode.ASCII:\n        size++;\n        if (input.isECI(fromPosition) || MinimalEncoder.isExtendedASCII(input.charAt(fromPosition), input.getFNC1Character())) {\n          size++;\n        }\n        if (previousMode === Mode.C40 || previousMode === Mode.TEXT || previousMode === Mode.X12) {\n          size++; // unlatch 254 to ASCII\n        }\n\n        break;\n      case Mode.B256:\n        size++;\n        if (previousMode !== Mode.B256) {\n          size++; // byte count\n        } else if (this.getB256Size() === 250) {\n          size++; // extra byte count\n        }\n\n        if (previousMode === Mode.ASCII) {\n          size++; // latch to B256\n        } else if (previousMode === Mode.C40 || previousMode === Mode.TEXT || previousMode === Mode.X12) {\n          size += 2; // unlatch to ASCII, latch to B256\n        }\n\n        break;\n      case Mode.C40:\n      case Mode.TEXT:\n      case Mode.X12:\n        if (mode === Mode.X12) {\n          size += 2;\n        } else {\n          var charLen = [];\n          size += MinimalEncoder.getNumberOfC40Words(input, fromPosition, mode === Mode.C40, charLen) * 2;\n        }\n        if (previousMode === Mode.ASCII || previousMode === Mode.B256) {\n          size++; // additional byte for latch from ASCII to this mode\n        } else if (previousMode !== mode && (previousMode === Mode.C40 || previousMode === Mode.TEXT || previousMode === Mode.X12)) {\n          size += 2; // unlatch 254 to ASCII followed by latch to this mode\n        }\n\n        break;\n      case Mode.EDF:\n        size += 3;\n        if (previousMode === Mode.ASCII || previousMode === Mode.B256) {\n          size++; // additional byte for latch from ASCII to this mode\n        } else if (previousMode === Mode.C40 || previousMode === Mode.TEXT || previousMode === Mode.X12) {\n          size += 2; // unlatch 254 to ASCII followed by latch to this mode\n        }\n\n        break;\n    }\n    this.cachedTotalSize = size;\n  }\n  // does not count beyond 250\n  Edge.prototype.getB256Size = function () {\n    var cnt = 0;\n    var current = this;\n    while (current !== null && current.mode === Mode.B256 && cnt <= 250) {\n      cnt++;\n      current = current.previous;\n    }\n    return cnt;\n  };\n  Edge.prototype.getPreviousStartMode = function () {\n    return this.previous === null ? Mode.ASCII : this.previous.mode;\n  };\n  Edge.prototype.getPreviousMode = function () {\n    return this.previous === null ? Mode.ASCII : this.previous.getEndMode();\n  };\n  /** Returns Mode.ASCII in case that:\n   *  - Mode is EDIFACT and characterLength is less than 4 or the remaining characters can be encoded in at most 2\n   *    ASCII bytes.\n   *  - Mode is C40, TEXT or X12 and the remaining characters can be encoded in at most 1 ASCII byte.\n   *  Returns mode in all other cases.\n   * */\n  Edge.prototype.getEndMode = function () {\n    if (this.mode === Mode.EDF) {\n      if (this.characterLength < 4) {\n        return Mode.ASCII;\n      }\n      var lastASCII = this.getLastASCII(); // see 5.2.8.2 EDIFACT encodation Rules\n      if (lastASCII > 0 && this.getCodewordsRemaining(this.cachedTotalSize + lastASCII) <= 2 - lastASCII) {\n        return Mode.ASCII;\n      }\n    }\n    if (this.mode === Mode.C40 || this.mode === Mode.TEXT || this.mode === Mode.X12) {\n      // see 5.2.5.2 C40 encodation rules and 5.2.7.2 ANSI X12 encodation rules\n      if (this.fromPosition + this.characterLength >= this.input.length() && this.getCodewordsRemaining(this.cachedTotalSize) === 0) {\n        return Mode.ASCII;\n      }\n      var lastASCII = this.getLastASCII();\n      if (lastASCII === 1 && this.getCodewordsRemaining(this.cachedTotalSize + 1) === 0) {\n        return Mode.ASCII;\n      }\n    }\n    return this.mode;\n  };\n  Edge.prototype.getMode = function () {\n    return this.mode;\n  };\n  /** Peeks ahead and returns 1 if the postfix consists of exactly two digits, 2 if the postfix consists of exactly\n   *  two consecutive digits and a non extended character or of 4 digits.\n   *  Returns 0 in any other case\n   **/\n  Edge.prototype.getLastASCII = function () {\n    var length = this.input.length();\n    var from = this.fromPosition + this.characterLength;\n    if (length - from > 4 || from >= length) {\n      return 0;\n    }\n    if (length - from === 1) {\n      if (MinimalEncoder.isExtendedASCII(this.input.charAt(from), this.input.getFNC1Character())) {\n        return 0;\n      }\n      return 1;\n    }\n    if (length - from === 2) {\n      if (MinimalEncoder.isExtendedASCII(this.input.charAt(from), this.input.getFNC1Character()) || MinimalEncoder.isExtendedASCII(this.input.charAt(from + 1), this.input.getFNC1Character())) {\n        return 0;\n      }\n      if (HighLevelEncoder.isDigit(this.input.charAt(from)) && HighLevelEncoder.isDigit(this.input.charAt(from + 1))) {\n        return 1;\n      }\n      return 2;\n    }\n    if (length - from === 3) {\n      if (HighLevelEncoder.isDigit(this.input.charAt(from)) && HighLevelEncoder.isDigit(this.input.charAt(from + 1)) && !MinimalEncoder.isExtendedASCII(this.input.charAt(from + 2), this.input.getFNC1Character())) {\n        return 2;\n      }\n      if (HighLevelEncoder.isDigit(this.input.charAt(from + 1)) && HighLevelEncoder.isDigit(this.input.charAt(from + 2)) && !MinimalEncoder.isExtendedASCII(this.input.charAt(from), this.input.getFNC1Character())) {\n        return 2;\n      }\n      return 0;\n    }\n    if (HighLevelEncoder.isDigit(this.input.charAt(from)) && HighLevelEncoder.isDigit(this.input.charAt(from + 1)) && HighLevelEncoder.isDigit(this.input.charAt(from + 2)) && HighLevelEncoder.isDigit(this.input.charAt(from + 3))) {\n      return 2;\n    }\n    return 0;\n  };\n  /** Returns the capacity in codewords of the smallest symbol that has enough capacity to fit the given minimal\n   * number of codewords.\n   **/\n  Edge.prototype.getMinSymbolSize = function (minimum) {\n    var e_3, _a, e_4, _b, e_5, _c;\n    switch (this.input.getShapeHint()) {\n      case 1 /* FORCE_SQUARE */:\n        try {\n          for (var _d = __values(this.squareCodewordCapacities), _e = _d.next(); !_e.done; _e = _d.next()) {\n            var capacity = _e.value;\n            if (capacity >= minimum) {\n              return capacity;\n            }\n          }\n        } catch (e_3_1) {\n          e_3 = {\n            error: e_3_1\n          };\n        } finally {\n          try {\n            if (_e && !_e.done && (_a = _d.return)) _a.call(_d);\n          } finally {\n            if (e_3) throw e_3.error;\n          }\n        }\n        break;\n      case 2 /* FORCE_RECTANGLE */:\n        try {\n          for (var _f = __values(this.rectangularCodewordCapacities), _g = _f.next(); !_g.done; _g = _f.next()) {\n            var capacity = _g.value;\n            if (capacity >= minimum) {\n              return capacity;\n            }\n          }\n        } catch (e_4_1) {\n          e_4 = {\n            error: e_4_1\n          };\n        } finally {\n          try {\n            if (_g && !_g.done && (_b = _f.return)) _b.call(_f);\n          } finally {\n            if (e_4) throw e_4.error;\n          }\n        }\n        break;\n    }\n    try {\n      for (var _h = __values(this.allCodewordCapacities), _j = _h.next(); !_j.done; _j = _h.next()) {\n        var capacity = _j.value;\n        if (capacity >= minimum) {\n          return capacity;\n        }\n      }\n    } catch (e_5_1) {\n      e_5 = {\n        error: e_5_1\n      };\n    } finally {\n      try {\n        if (_j && !_j.done && (_c = _h.return)) _c.call(_h);\n      } finally {\n        if (e_5) throw e_5.error;\n      }\n    }\n    return this.allCodewordCapacities[this.allCodewordCapacities.length - 1];\n  };\n  /** Returns the remaining capacity in codewords of the smallest symbol that has enough capacity to fit the given\n   * minimal number of codewords.\n   **/\n  Edge.prototype.getCodewordsRemaining = function (minimum) {\n    return this.getMinSymbolSize(minimum) - minimum;\n  };\n  Edge.getBytes = function (c1, c2) {\n    var result = new Uint8Array(c2 ? 2 : 1);\n    result[0] = c1;\n    if (c2) {\n      result[1] = c2;\n    }\n    return result;\n  };\n  Edge.prototype.setC40Word = function (bytes, offset, c1, c2, c3) {\n    var val16 = 1600 * (c1 & 0xff) + 40 * (c2 & 0xff) + (c3 & 0xff) + 1;\n    bytes[offset] = val16 / 256;\n    bytes[offset + 1] = val16 % 256;\n  };\n  Edge.prototype.getX12Value = function (c) {\n    return c === 13 ? 0 : c === 42 ? 1 : c === 62 ? 2 : c === 32 ? 3 : c >= 48 && c <= 57 ? c - 44 : c >= 65 && c <= 90 ? c - 51 : c;\n  };\n  Edge.prototype.getX12Words = function () {\n    if (!(this.characterLength % 3 === 0)) {\n      throw new Error('X12 words must be a multiple of 3');\n    }\n    var result = new Uint8Array(this.characterLength / 3 * 2);\n    for (var i = 0; i < result.length; i += 2) {\n      this.setC40Word(result, i, this.getX12Value(this.input.charAt(this.fromPosition + i / 2 * 3)), this.getX12Value(this.input.charAt(this.fromPosition + i / 2 * 3 + 1)), this.getX12Value(this.input.charAt(this.fromPosition + i / 2 * 3 + 2)));\n    }\n    return result;\n  };\n  Edge.prototype.getShiftValue = function (c, c40, fnc1) {\n    return c40 && MinimalEncoder.isInC40Shift1Set(c) || !c40 && MinimalEncoder.isInTextShift1Set(c) ? 0 : c40 && MinimalEncoder.isInC40Shift2Set(c, fnc1) || !c40 && MinimalEncoder.isInTextShift2Set(c, fnc1) ? 1 : 2;\n  };\n  Edge.prototype.getC40Value = function (c40, setIndex, c, fnc1) {\n    if (c === fnc1) {\n      if (!(setIndex === 2)) {\n        throw new Error('FNC1 cannot be used in C40 shift 2');\n      }\n      return 27;\n    }\n    if (c40) {\n      return c <= 31 ? c : c === 32 ? 3 : c <= 47 ? c - 33 : c <= 57 ? c - 44 : c <= 64 ? c - 43 : c <= 90 ? c - 51 : c <= 95 ? c - 69 : c <= 127 ? c - 96 : c;\n    } else {\n      return c === 0 ? 0 : setIndex === 0 && c <= 3 ? c - 1 // is this a bug in the spec?\n      : setIndex === 1 && c <= 31 ? c : c === 32 ? 3 : c >= 33 && c <= 47 ? c - 33 : c >= 48 && c <= 57 ? c - 44 : c >= 58 && c <= 64 ? c - 43 : c >= 65 && c <= 90 ? c - 64 : c >= 91 && c <= 95 ? c - 69 : c === 96 ? 0 : c >= 97 && c <= 122 ? c - 83 : c >= 123 && c <= 127 ? c - 96 : c;\n    }\n  };\n  Edge.prototype.getC40Words = function (c40, fnc1) {\n    var c40Values = [];\n    for (var i = 0; i < this.characterLength; i++) {\n      var ci = this.input.charAt(this.fromPosition + i);\n      if (c40 && HighLevelEncoder.isNativeC40(ci) || !c40 && HighLevelEncoder.isNativeText(ci)) {\n        c40Values.push(this.getC40Value(c40, 0, ci, fnc1));\n      } else if (!MinimalEncoder.isExtendedASCII(ci, fnc1)) {\n        var shiftValue = this.getShiftValue(ci, c40, fnc1);\n        c40Values.push(shiftValue); // Shift[123]\n        c40Values.push(this.getC40Value(c40, shiftValue, ci, fnc1));\n      } else {\n        var asciiValue = (ci & 0xff) - 128;\n        if (c40 && HighLevelEncoder.isNativeC40(asciiValue) || !c40 && HighLevelEncoder.isNativeText(asciiValue)) {\n          c40Values.push(1); // Shift 2\n          c40Values.push(30); // Upper Shift\n          c40Values.push(this.getC40Value(c40, 0, asciiValue, fnc1));\n        } else {\n          c40Values.push(1); // Shift 2\n          c40Values.push(30); // Upper Shift\n          var shiftValue = this.getShiftValue(asciiValue, c40, fnc1);\n          c40Values.push(shiftValue); // Shift[123]\n          c40Values.push(this.getC40Value(c40, shiftValue, asciiValue, fnc1));\n        }\n      }\n    }\n    if (c40Values.length % 3 !== 0) {\n      if (!((c40Values.length - 2) % 3 === 0 && this.fromPosition + this.characterLength === this.input.length())) {\n        throw new Error('C40 words must be a multiple of 3');\n      }\n      c40Values.push(0); // pad with 0 (Shift 1)\n    }\n\n    var result = new Uint8Array(c40Values.length / 3 * 2);\n    var byteIndex = 0;\n    for (var i = 0; i < c40Values.length; i += 3) {\n      this.setC40Word(result, byteIndex, c40Values[i] & 0xff, c40Values[i + 1] & 0xff, c40Values[i + 2] & 0xff);\n      byteIndex += 2;\n    }\n    return result;\n  };\n  Edge.prototype.getEDFBytes = function () {\n    var numberOfThirds = Math.ceil(this.characterLength / 4.0);\n    var result = new Uint8Array(numberOfThirds * 3);\n    var pos = this.fromPosition;\n    var endPos = Math.min(this.fromPosition + this.characterLength - 1, this.input.length() - 1);\n    for (var i = 0; i < numberOfThirds; i += 3) {\n      var edfValues = [];\n      for (var j = 0; j < 4; j++) {\n        if (pos <= endPos) {\n          edfValues[j] = this.input.charAt(pos++) & 0x3f;\n        } else {\n          edfValues[j] = pos === endPos + 1 ? 0x1f : 0;\n        }\n      }\n      var val24 = edfValues[0] << 18;\n      val24 |= edfValues[1] << 12;\n      val24 |= edfValues[2] << 6;\n      val24 |= edfValues[3];\n      result[i] = val24 >> 16 & 0xff;\n      result[i + 1] = val24 >> 8 & 0xff;\n      result[i + 2] = val24 & 0xff;\n    }\n    return result;\n  };\n  Edge.prototype.getLatchBytes = function () {\n    switch (this.getPreviousMode()) {\n      case Mode.ASCII:\n      case Mode.B256:\n        // after B256 ends (via length) we are back to ASCII\n        switch (this.mode) {\n          case Mode.B256:\n            return Edge.getBytes(231);\n          case Mode.C40:\n            return Edge.getBytes(230);\n          case Mode.TEXT:\n            return Edge.getBytes(239);\n          case Mode.X12:\n            return Edge.getBytes(238);\n          case Mode.EDF:\n            return Edge.getBytes(240);\n        }\n        break;\n      case Mode.C40:\n      case Mode.TEXT:\n      case Mode.X12:\n        if (this.mode !== this.getPreviousMode()) {\n          switch (this.mode) {\n            case Mode.ASCII:\n              return Edge.getBytes(254);\n            case Mode.B256:\n              return Edge.getBytes(254, 231);\n            case Mode.C40:\n              return Edge.getBytes(254, 230);\n            case Mode.TEXT:\n              return Edge.getBytes(254, 239);\n            case Mode.X12:\n              return Edge.getBytes(254, 238);\n            case Mode.EDF:\n              return Edge.getBytes(254, 240);\n          }\n        }\n        break;\n      case Mode.EDF:\n        // The rightmost EDIFACT edge always contains an unlatch character\n        if (this.mode !== Mode.EDF) {\n          throw new Error('Cannot switch from EDF to ' + this.mode);\n        }\n        break;\n    }\n    return new Uint8Array(0);\n  };\n  // Important: The function does not return the length bytes (one or two) in case of B256 encoding\n  Edge.prototype.getDataBytes = function () {\n    switch (this.mode) {\n      case Mode.ASCII:\n        if (this.input.isECI(this.fromPosition)) {\n          return Edge.getBytes(241, this.input.getECIValue(this.fromPosition) + 1);\n        } else if (MinimalEncoder.isExtendedASCII(this.input.charAt(this.fromPosition), this.input.getFNC1Character())) {\n          return Edge.getBytes(235, this.input.charAt(this.fromPosition) - 127);\n        } else if (this.characterLength === 2) {\n          return Edge.getBytes(this.input.charAt(this.fromPosition) * 10 + this.input.charAt(this.fromPosition + 1) + 130);\n        } else if (this.input.isFNC1(this.fromPosition)) {\n          return Edge.getBytes(232);\n        } else {\n          return Edge.getBytes(this.input.charAt(this.fromPosition) + 1);\n        }\n      case Mode.B256:\n        return Edge.getBytes(this.input.charAt(this.fromPosition));\n      case Mode.C40:\n        return this.getC40Words(true, this.input.getFNC1Character());\n      case Mode.TEXT:\n        return this.getC40Words(false, this.input.getFNC1Character());\n      case Mode.X12:\n        return this.getX12Words();\n      case Mode.EDF:\n        return this.getEDFBytes();\n    }\n  };\n  return Edge;\n}();\nvar Input = /** @class */function (_super) {\n  __extends(Input, _super);\n  function Input(stringToEncode, priorityCharset, fnc1, shape, macroId) {\n    var _this = _super.call(this, stringToEncode, priorityCharset, fnc1) || this;\n    _this.shape = shape;\n    _this.macroId = macroId;\n    return _this;\n  }\n  Input.prototype.getMacroId = function () {\n    return this.macroId;\n  };\n  Input.prototype.getShapeHint = function () {\n    return this.shape;\n  };\n  return Input;\n}(MinimalECIInput);","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}