{"ast":null,"code":"import StringBuilder from '../../util/StringBuilder';\nimport HighLevelEncoder from './HighLevelEncoder';\nimport { C40_ENCODATION, LATCH_TO_C40, ASCII_ENCODATION, C40_UNLATCH } from './constants';\nvar C40Encoder = /** @class */function () {\n  function C40Encoder() {}\n  C40Encoder.prototype.getEncodingMode = function () {\n    return C40_ENCODATION;\n  };\n  C40Encoder.prototype.encodeMaximal = function (context) {\n    var buffer = new StringBuilder();\n    var lastCharSize = 0;\n    var backtrackStartPosition = context.pos;\n    var backtrackBufferLength = 0;\n    while (context.hasMoreCharacters()) {\n      var c = context.getCurrentChar();\n      context.pos++;\n      lastCharSize = this.encodeChar(c, buffer);\n      if (buffer.length() % 3 === 0) {\n        backtrackStartPosition = context.pos;\n        backtrackBufferLength = buffer.length();\n      }\n    }\n    if (backtrackBufferLength !== buffer.length()) {\n      var unwritten = Math.floor(buffer.length() / 3 * 2);\n      var curCodewordCount = Math.floor(context.getCodewordCount() + unwritten + 1); // +1 for the latch to C40\n      context.updateSymbolInfo(curCodewordCount);\n      var available = context.getSymbolInfo().getDataCapacity() - curCodewordCount;\n      var rest = Math.floor(buffer.length() % 3);\n      if (rest === 2 && available !== 2 || rest === 1 && (lastCharSize > 3 || available !== 1)) {\n        // buffer.setLength(backtrackBufferLength);\n        context.pos = backtrackStartPosition;\n      }\n    }\n    if (buffer.length() > 0) {\n      context.writeCodeword(LATCH_TO_C40);\n    }\n    this.handleEOD(context, buffer);\n  };\n  C40Encoder.prototype.encode = function (context) {\n    // step C\n    var buffer = new StringBuilder();\n    while (context.hasMoreCharacters()) {\n      var c = context.getCurrentChar();\n      context.pos++;\n      var lastCharSize = this.encodeChar(c, buffer);\n      var unwritten = Math.floor(buffer.length() / 3) * 2;\n      var curCodewordCount = context.getCodewordCount() + unwritten;\n      context.updateSymbolInfo(curCodewordCount);\n      var available = context.getSymbolInfo().getDataCapacity() - curCodewordCount;\n      if (!context.hasMoreCharacters()) {\n        // Avoid having a single C40 value in the last triplet\n        var removed = new StringBuilder();\n        if (buffer.length() % 3 === 2 && available !== 2) {\n          lastCharSize = this.backtrackOneCharacter(context, buffer, removed, lastCharSize);\n        }\n        while (buffer.length() % 3 === 1 && (lastCharSize > 3 || available !== 1)) {\n          lastCharSize = this.backtrackOneCharacter(context, buffer, removed, lastCharSize);\n        }\n        break;\n      }\n      var count = buffer.length();\n      if (count % 3 === 0) {\n        var newMode = HighLevelEncoder.lookAheadTest(context.getMessage(), context.pos, this.getEncodingMode());\n        if (newMode !== this.getEncodingMode()) {\n          // Return to ASCII encodation, which will actually handle latch to new mode\n          context.signalEncoderChange(ASCII_ENCODATION);\n          break;\n        }\n      }\n    }\n    this.handleEOD(context, buffer);\n  };\n  C40Encoder.prototype.backtrackOneCharacter = function (context, buffer, removed, lastCharSize) {\n    var count = buffer.length();\n    var test = buffer.toString().substring(0, count - lastCharSize);\n    buffer.setLengthToZero();\n    buffer.append(test);\n    // buffer.delete(count - lastCharSize, count);\n    /*for (let i = count - lastCharSize; i < count; i++) {\n      buffer.deleteCharAt(i);\n    }*/\n    context.pos--;\n    var c = context.getCurrentChar();\n    lastCharSize = this.encodeChar(c, removed);\n    context.resetSymbolInfo(); // Deal with possible reduction in symbol size\n    return lastCharSize;\n  };\n  C40Encoder.prototype.writeNextTriplet = function (context, buffer) {\n    context.writeCodewords(this.encodeToCodewords(buffer.toString()));\n    var test = buffer.toString().substring(3);\n    buffer.setLengthToZero();\n    buffer.append(test);\n    // buffer.delete(0, 3);\n    /*for (let i = 0; i < 3; i++) {\n      buffer.deleteCharAt(i);\n    }*/\n  };\n  /**\n   * Handle \"end of data\" situations\n   *\n   * @param context the encoder context\n   * @param buffer  the buffer with the remaining encoded characters\n   */\n  C40Encoder.prototype.handleEOD = function (context, buffer) {\n    var unwritten = Math.floor(buffer.length() / 3 * 2);\n    var rest = buffer.length() % 3;\n    var curCodewordCount = context.getCodewordCount() + unwritten;\n    context.updateSymbolInfo(curCodewordCount);\n    var available = context.getSymbolInfo().getDataCapacity() - curCodewordCount;\n    if (rest === 2) {\n      buffer.append('\\0'); // Shift 1\n      while (buffer.length() >= 3) {\n        this.writeNextTriplet(context, buffer);\n      }\n      if (context.hasMoreCharacters()) {\n        context.writeCodeword(C40_UNLATCH);\n      }\n    } else if (available === 1 && rest === 1) {\n      while (buffer.length() >= 3) {\n        this.writeNextTriplet(context, buffer);\n      }\n      if (context.hasMoreCharacters()) {\n        context.writeCodeword(C40_UNLATCH);\n      }\n      // else no unlatch\n      context.pos--;\n    } else if (rest === 0) {\n      while (buffer.length() >= 3) {\n        this.writeNextTriplet(context, buffer);\n      }\n      if (available > 0 || context.hasMoreCharacters()) {\n        context.writeCodeword(C40_UNLATCH);\n      }\n    } else {\n      throw new Error('Unexpected case. Please report!');\n    }\n    context.signalEncoderChange(ASCII_ENCODATION);\n  };\n  C40Encoder.prototype.encodeChar = function (c, sb) {\n    if (c === ' '.charCodeAt(0)) {\n      sb.append(3);\n      return 1;\n    }\n    if (c >= '0'.charCodeAt(0) && c <= '9'.charCodeAt(0)) {\n      sb.append(c - 48 + 4);\n      return 1;\n    }\n    if (c >= 'A'.charCodeAt(0) && c <= 'Z'.charCodeAt(0)) {\n      sb.append(c - 65 + 14);\n      return 1;\n    }\n    if (c < ' '.charCodeAt(0)) {\n      sb.append(0); // Shift 1 Set\n      sb.append(c);\n      return 2;\n    }\n    if (c <= '/'.charCodeAt(0)) {\n      sb.append(1); // Shift 2 Set\n      sb.append(c - 33);\n      return 2;\n    }\n    if (c <= '@'.charCodeAt(0)) {\n      sb.append(1); // Shift 2 Set\n      sb.append(c - 58 + 15);\n      return 2;\n    }\n    if (c <= '_'.charCodeAt(0)) {\n      sb.append(1); // Shift 2 Set\n      sb.append(c - 91 + 22);\n      return 2;\n    }\n    if (c <= 127) {\n      sb.append(2); // Shift 3 Set\n      sb.append(c - 96);\n      return 2;\n    }\n    sb.append(1 + \"\\u001E\"); // Shift 2, Upper Shift\n    var len = 2;\n    len += this.encodeChar(c - 128, sb);\n    return len;\n  };\n  C40Encoder.prototype.encodeToCodewords = function (sb) {\n    var v = 1600 * sb.charCodeAt(0) + 40 * sb.charCodeAt(1) + sb.charCodeAt(2) + 1;\n    var cw1 = v / 256;\n    var cw2 = v % 256;\n    var result = new StringBuilder();\n    result.append(cw1);\n    result.append(cw2);\n    return result.toString();\n  };\n  return C40Encoder;\n}();\nexport { C40Encoder };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}