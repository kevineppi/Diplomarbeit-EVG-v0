{"ast":null,"code":"import _asyncToGenerator from \"C:/Users/Kevin/source/repos/Diplomarbeit-EVG/Diplomarbeit-EVG/ClientApp/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { CommonModule } from '@angular/common';\nimport * as i0 from '@angular/core';\nimport { EventEmitter, Component, ChangeDetectionStrategy, ViewChild, Input, Output, NgModule } from '@angular/core';\nimport { FormsModule } from '@angular/forms';\nimport { BrowserMultiFormatReader, BrowserCodeReader } from '@zxing/browser';\nimport { NotFoundException, ChecksumException, FormatException, DecodeHintType, BarcodeFormat } from '@zxing/library';\nimport { BehaviorSubject } from 'rxjs';\n\n/**\n * Based on zxing-typescript BrowserCodeReader\n */\nconst _c0 = [\"preview\"];\nclass BrowserMultiFormatContinuousReader extends BrowserMultiFormatReader {\n  /**\n   * Returns the code reader scanner controls.\n   */\n  getScannerControls() {\n    if (!this.scannerControls) {\n      throw new Error('No scanning is running at the time.');\n    }\n    return this.scannerControls;\n  }\n  /**\n   * Starts the decoding from the current or a new video element.\n   *\n   * @param deviceId The device's to be used Id\n   * @param previewEl A new video element\n   */\n  scanFromDeviceObservable(deviceId, previewEl) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      const scan$ = new BehaviorSubject({});\n      let ctrls;\n      try {\n        ctrls = yield _this.decodeFromVideoDevice(deviceId, previewEl, (result, error) => {\n          if (!error) {\n            scan$.next({\n              result\n            });\n            return;\n          }\n          const errorName = error.name;\n          // stream cannot stop on fails.\n          if (\n          // scan Failure - found nothing, no error\n          errorName === NotFoundException.name ||\n          // scan Error - found the QR but got error on decoding\n          errorName === ChecksumException.name || errorName === FormatException.name || error.message.includes('No MultiFormat Readers were able to detect the code.')) {\n            scan$.next({\n              error\n            });\n            return;\n          }\n          // probably fatal error\n          scan$.error(error);\n          _this.scannerControls.stop();\n          _this.scannerControls = undefined;\n          return;\n        });\n        _this.scannerControls = {\n          ...ctrls,\n          stop() {\n            ctrls.stop();\n            scan$.complete();\n          }\n        };\n      } catch (e) {\n        scan$.error(e);\n        _this.scannerControls?.stop();\n        _this.scannerControls = undefined;\n      }\n      return scan$.asObservable();\n    })();\n  }\n}\nclass ZXingScannerComponent {\n  /**\n   * Exposes the current code reader, so the user can use it's APIs.\n   */\n  get codeReader() {\n    return this._codeReader;\n  }\n  /**\n   * User device input\n   */\n  set device(device) {\n    if (!this._ready) {\n      this._devicePreStart = device;\n      // let's ignore silently, users don't like logs\n      return;\n    }\n    if (this.isAutostarting) {\n      // do not allow setting devices during auto-start, since it will set one and emit it.\n      console.warn('Avoid setting a device during auto-start.');\n      return;\n    }\n    if (this.isCurrentDevice(device)) {\n      console.warn('Setting the same device is not allowed.');\n      return;\n    }\n    if (!this.hasPermission) {\n      console.warn('Permissions not set yet, waiting for them to be set to apply device change.');\n      // this.permissionResponse\n      //   .pipe(\n      //     take(1),\n      //     tap(() => console.log(`Permissions set, applying device change${device ? ` (${device.deviceId})` : ''}.`))\n      //   )\n      //   .subscribe(() => this.device = device);\n      return;\n    }\n    this.setDevice(device);\n  }\n  /**\n   * User device accessor.\n   */\n  get device() {\n    return this._device;\n  }\n  /**\n   * Returns all the registered formats.\n   */\n  get formats() {\n    return this.hints.get(DecodeHintType.POSSIBLE_FORMATS);\n  }\n  /**\n   * Registers formats the scanner should support.\n   *\n   * @param input BarcodeFormat or case-insensitive string array.\n   */\n  set formats(input) {\n    if (typeof input === 'string') {\n      throw new Error('Invalid formats, make sure the [formats] input is a binding.');\n    }\n    // formats may be set from html template as BarcodeFormat or string array\n    const formats = input.map(f => this.getBarcodeFormatOrFail(f));\n    const hints = this.hints;\n    // updates the hints\n    hints.set(DecodeHintType.POSSIBLE_FORMATS, formats);\n    // handles updating the codeReader\n    this.hints = hints;\n  }\n  /**\n   * Returns all the registered hints.\n   */\n  get hints() {\n    return this._hints;\n  }\n  /**\n   * Does what it takes to set the hints.\n   */\n  set hints(hints) {\n    this._hints = hints;\n    // new instance with new hints.\n    this.codeReader?.setHints(this._hints);\n  }\n  /**\n   * Sets the desired constraints in all video tracks.\n   * @experimental\n   */\n  set videoConstraints(constraints) {\n    // new instance with new hints.\n    const controls = this.codeReader?.getScannerControls();\n    if (!controls) {\n      // fails silently\n      return;\n    }\n    controls?.streamVideoConstraintsApply(constraints);\n  }\n  /**\n   *\n   */\n  set isAutostarting(state) {\n    this._isAutostarting = state;\n    this.autostarting.next(state);\n  }\n  /**\n   *\n   */\n  get isAutostarting() {\n    return this._isAutostarting;\n  }\n  /**\n   * Can turn on/off the device flashlight.\n   *\n   * @experimental Torch/Flash APIs are not stable in all browsers, it may be buggy!\n   */\n  set torch(onOff) {\n    try {\n      const controls = this.getCodeReader().getScannerControls();\n      controls.switchTorch(onOff);\n    } catch (error) {\n      // ignore error\n    }\n  }\n  /**\n   * Starts and Stops the scanning.\n   */\n  set enable(enabled) {\n    this._enabled = Boolean(enabled);\n    if (!this._enabled) {\n      this.reset();\n      BrowserMultiFormatContinuousReader.releaseAllStreams();\n    } else {\n      if (this.device) {\n        this.scanFromDevice(this.device.deviceId);\n      } else {\n        this.init();\n      }\n    }\n  }\n  /**\n   * Tells if the scanner is enabled or not.\n   */\n  get enabled() {\n    return this._enabled;\n  }\n  /**\n   * If is `tryHarder` enabled.\n   */\n  get tryHarder() {\n    return this.hints.get(DecodeHintType.TRY_HARDER);\n  }\n  /**\n   * Enable/disable tryHarder hint.\n   */\n  set tryHarder(enable) {\n    const hints = this.hints;\n    if (enable) {\n      hints.set(DecodeHintType.TRY_HARDER, true);\n    } else {\n      hints.delete(DecodeHintType.TRY_HARDER);\n    }\n    this.hints = hints;\n  }\n  /**\n   * Constructor to build the object and do some DI.\n   */\n  constructor() {\n    /**\n     * Delay between attempts to decode (default is 500ms)\n     */\n    this.timeBetweenScans = 500;\n    /**\n     * Delay between successful decode (default is 500ms)\n     */\n    this.delayBetweenScanSuccess = 500;\n    /**\n     * How the preview element should be fit inside the :host container.\n     */\n    this.previewFitMode = 'cover';\n    /**\n     * Url of the HTML video poster\n     */\n    this.poster = '';\n    this._ready = false;\n    // instance based emitters\n    this.autostarted = new EventEmitter();\n    this.autostarting = new EventEmitter();\n    this.torchCompatible = new EventEmitter(false);\n    this.scanSuccess = new EventEmitter();\n    this.scanFailure = new EventEmitter();\n    this.scanError = new EventEmitter();\n    this.scanComplete = new EventEmitter();\n    this.camerasFound = new EventEmitter();\n    this.camerasNotFound = new EventEmitter();\n    this.permissionResponse = new EventEmitter(true);\n    this.hasDevices = new EventEmitter();\n    this.deviceChange = new EventEmitter();\n    this._enabled = true;\n    this._hints = new Map();\n    this.autofocusEnabled = true;\n    this.autostart = true;\n    this.formats = [BarcodeFormat.QR_CODE];\n    // computed data\n    this.hasNavigator = typeof navigator !== 'undefined';\n    this.isMediaDevicesSupported = this.hasNavigator && !!navigator.mediaDevices;\n  }\n  /**\n   * Gets and registers all cameras.\n   */\n  askForPermission() {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      if (!_this2.hasNavigator) {\n        console.error('@zxing/ngx-scanner', 'Can\\'t ask permission, navigator is not present.');\n        _this2.setPermission(null);\n        return _this2.hasPermission;\n      }\n      if (!_this2.isMediaDevicesSupported) {\n        console.error('@zxing/ngx-scanner', 'Can\\'t get user media, this is not supported.');\n        _this2.setPermission(null);\n        return _this2.hasPermission;\n      }\n      let stream;\n      let permission;\n      try {\n        // Will try to ask for permission\n        stream = yield _this2.getAnyVideoDevice();\n        permission = !!stream;\n      } catch (err) {\n        return _this2.handlePermissionException(err);\n      } finally {\n        _this2.terminateStream(stream);\n      }\n      _this2.setPermission(permission);\n      // Returns the permission\n      return permission;\n    })();\n  }\n  /**\n   *\n   */\n  getAnyVideoDevice() {\n    return navigator.mediaDevices.getUserMedia({\n      video: true\n    });\n  }\n  /**\n   * Terminates a stream and it's tracks.\n   */\n  terminateStream(stream) {\n    if (stream) {\n      stream.getTracks().forEach(t => t.stop());\n    }\n    stream = undefined;\n  }\n  init() {\n    var _this3 = this;\n    return _asyncToGenerator(function* () {\n      if (!_this3.autostart) {\n        console.warn('Feature \\'autostart\\' disabled. Permissions and devices recovery has to be run manually.');\n        // does the necessary configuration without autostarting\n        _this3.initAutostartOff();\n        _this3._ready = true;\n        return;\n      }\n      // configures the component and starts the scanner\n      yield _this3.initAutostartOn();\n      _this3._ready = true;\n    })();\n  }\n  /**\n   * Initializes the component without starting the scanner.\n   */\n  initAutostartOff() {\n    // do not ask for permission when autostart is off\n    this.isAutostarting = false;\n    // just update devices information\n    this.updateVideoInputDevices();\n    if (this._device && this._devicePreStart) {\n      this.setDevice(this._devicePreStart);\n    }\n  }\n  /**\n   * Initializes the component and starts the scanner.\n   * Permissions are asked to accomplish that.\n   */\n  initAutostartOn() {\n    var _this4 = this;\n    return _asyncToGenerator(function* () {\n      _this4.isAutostarting = true;\n      let hasPermission;\n      try {\n        // Asks for permission before enumerating devices so it can get all the device's info\n        hasPermission = yield _this4.askForPermission();\n      } catch (e) {\n        console.error('Exception occurred while asking for permission:', e);\n        return;\n      }\n      // from this point, things gonna need permissions\n      if (hasPermission) {\n        const devices = yield _this4.updateVideoInputDevices();\n        yield _this4.autostartScanner([...devices]);\n      }\n      _this4.isAutostarting = false;\n      _this4.autostarted.next();\n    })();\n  }\n  /**\n   * Checks if the given device is the current defined one.\n   */\n  isCurrentDevice(device) {\n    return device?.deviceId === this._device?.deviceId;\n  }\n  /**\n   * Executes some actions before destroy the component.\n   */\n  ngOnDestroy() {\n    this.reset();\n    BrowserMultiFormatContinuousReader.releaseAllStreams();\n  }\n  /**\n   *\n   */\n  ngOnInit() {\n    this.init();\n  }\n  /**\n   * Stops the scanning, if any.\n   */\n  scanStop() {\n    if (this._scanSubscription) {\n      this.codeReader?.getScannerControls().stop();\n      this._scanSubscription?.unsubscribe();\n      this._scanSubscription = undefined;\n    }\n    this.torchCompatible.next(false);\n  }\n  /**\n   * Stops the scanning, if any.\n   */\n  scanStart() {\n    if (this._scanSubscription) {\n      throw new Error('There is already a scan process running.');\n    }\n    if (!this._device) {\n      throw new Error('No device defined, cannot start scan, please define a device.');\n    }\n    this.scanFromDevice(this._device.deviceId);\n  }\n  /**\n   * Stops old `codeReader` and starts scanning in a new one.\n   */\n  restart() {\n    // note only necessary for now because of the Torch\n    this._codeReader = undefined;\n    const prevDevice = this._reset();\n    if (!prevDevice) {\n      return;\n    }\n    this.device = prevDevice;\n  }\n  /**\n   * Discovers and updates known video input devices.\n   */\n  updateVideoInputDevices() {\n    var _this5 = this;\n    return _asyncToGenerator(function* () {\n      // permissions aren't needed to get devices, but to access them and their info\n      const devices = (yield BrowserCodeReader.listVideoInputDevices()) || [];\n      const hasDevices = devices && devices.length > 0;\n      // stores discovered devices and updates information\n      _this5.hasDevices.next(hasDevices);\n      _this5.camerasFound.next([...devices]);\n      if (!hasDevices) {\n        _this5.camerasNotFound.next(null);\n      }\n      return devices;\n    })();\n  }\n  /**\n   * Starts the scanner with the back camera otherwise take the last\n   * available device.\n   */\n  autostartScanner(devices) {\n    var _this6 = this;\n    return _asyncToGenerator(function* () {\n      const matcher = ({\n        label\n      }) => /back|trás|rear|traseira|environment|ambiente/gi.test(label);\n      // select the rear camera by default, otherwise take the last camera.\n      const device = devices.find(matcher) || devices.pop();\n      if (!device) {\n        throw new Error('Impossible to autostart, no input devices available.');\n      }\n      yield _this6.setDevice(device);\n      _this6.deviceChange.next(device);\n    })();\n  }\n  /**\n   * Dispatches the scan success event.\n   *\n   * @param result the scan result.\n   */\n  dispatchScanSuccess(result) {\n    this.scanSuccess.next(result.getText());\n  }\n  /**\n   * Dispatches the scan failure event.\n   */\n  dispatchScanFailure(reason) {\n    this.scanFailure.next(reason);\n  }\n  /**\n   * Dispatches the scan error event.\n   *\n   * @param error the error thing.\n   */\n  dispatchScanError(error) {\n    if (!this.scanError.observed) {\n      console.error(`zxing scanner component: ${error.name}`, error);\n      console.warn('Use the `(scanError)` property to handle errors like this!');\n    }\n    this.scanError.next(error);\n  }\n  /**\n   * Dispatches the scan event.\n   *\n   * @param result the scan result.\n   */\n  dispatchScanComplete(result) {\n    this.scanComplete.next(result);\n  }\n  /**\n   * Returns the filtered permission.\n   */\n  handlePermissionException(err) {\n    // failed to grant permission to video input\n    console.error('@zxing/ngx-scanner', 'Error when asking for permission.', err);\n    let permission;\n    switch (err.name) {\n      // usually caused by not secure origins\n      case 'NotSupportedError':\n        console.warn('@zxing/ngx-scanner', err.message);\n        // could not claim\n        permission = null;\n        // can't check devices\n        this.hasDevices.next(null);\n        break;\n      // user denied permission\n      case 'NotAllowedError':\n        console.warn('@zxing/ngx-scanner', err.message);\n        // claimed and denied permission\n        permission = false;\n        // this means that input devices exists\n        this.hasDevices.next(true);\n        break;\n      // the device has no attached input devices\n      case 'NotFoundError':\n        console.warn('@zxing/ngx-scanner', err.message);\n        // no permissions claimed\n        permission = null;\n        // because there was no devices\n        this.hasDevices.next(false);\n        // tells the listener about the error\n        this.camerasNotFound.next(err);\n        break;\n      case 'NotReadableError':\n        console.warn('@zxing/ngx-scanner', 'Couldn\\'t read the device(s)\\'s stream, it\\'s probably in use by another app.');\n        // no permissions claimed\n        permission = null;\n        // there are devices, which I couldn't use\n        this.hasDevices.next(false);\n        // tells the listener about the error\n        this.camerasNotFound.next(err);\n        break;\n      default:\n        console.warn('@zxing/ngx-scanner', 'I was not able to define if I have permissions for camera or not.', err);\n        // unknown\n        permission = null;\n        // this.hasDevices.next(undefined;\n        break;\n    }\n    this.setPermission(permission);\n    // tells the listener about the error\n    this.permissionResponse.error(err);\n    return permission;\n  }\n  /**\n   * Returns a valid BarcodeFormat or fails.\n   */\n  getBarcodeFormatOrFail(format) {\n    return typeof format === 'string' ? BarcodeFormat[format.trim().toUpperCase()] : format;\n  }\n  /**\n   * Return a code reader, create one if non exist\n   */\n  getCodeReader() {\n    if (!this._codeReader) {\n      const options = {\n        delayBetweenScanAttempts: this.timeBetweenScans,\n        delayBetweenScanSuccess: this.delayBetweenScanSuccess\n      };\n      this._codeReader = new BrowserMultiFormatContinuousReader(this.hints, options);\n    }\n    return this._codeReader;\n  }\n  /**\n   * Starts the continuous scanning for the given device.\n   *\n   * @param deviceId The deviceId from the device.\n   */\n  scanFromDevice(deviceId) {\n    var _this7 = this;\n    return _asyncToGenerator(function* () {\n      const videoElement = _this7.previewElemRef.nativeElement;\n      const codeReader = _this7.getCodeReader();\n      const scanStream = yield codeReader.scanFromDeviceObservable(deviceId, videoElement);\n      if (!scanStream) {\n        throw new Error('Undefined decoding stream, aborting.');\n      }\n      const next = x => _this7._onDecodeResult(x.result, x.error);\n      const error = err => _this7._onDecodeError(err);\n      const complete = () => {};\n      _this7._scanSubscription = scanStream.subscribe(next, error, complete);\n      if (_this7._scanSubscription.closed) {\n        return;\n      }\n      const controls = codeReader.getScannerControls();\n      const hasTorchControl = typeof controls.switchTorch !== 'undefined';\n      _this7.torchCompatible.next(hasTorchControl);\n    })();\n  }\n  /**\n   * Handles decode errors.\n   */\n  _onDecodeError(err) {\n    this.dispatchScanError(err);\n    // this.reset();\n  }\n  /**\n   * Handles decode results.\n   */\n  _onDecodeResult(result, error) {\n    if (result) {\n      this.dispatchScanSuccess(result);\n    } else {\n      this.dispatchScanFailure(error);\n    }\n    this.dispatchScanComplete(result);\n  }\n  /**\n   * Stops the code reader and returns the previous selected device.\n   */\n  _reset() {\n    if (!this._codeReader) {\n      return;\n    }\n    // clearing codeReader first to prevent setOptions error appearing in several Chromium versions\n    this._codeReader = undefined;\n    const device = this._device;\n    // do not set this.device inside this method, it would create a recursive loop\n    this.device = undefined;\n    return device;\n  }\n  /**\n   * Resets the scanner and emits device change.\n   */\n  reset() {\n    this._reset();\n    this.deviceChange.emit(null);\n  }\n  /**\n   * Sets the current device.\n   */\n  setDevice(device) {\n    var _this8 = this;\n    return _asyncToGenerator(function* () {\n      // instantly stops the scan before changing devices\n      _this8.scanStop();\n      // correctly sets the new (or none) device\n      _this8._device = device || undefined;\n      if (!_this8._device) {\n        // cleans the video because user removed the device\n        BrowserCodeReader.cleanVideoSource(_this8.previewElemRef.nativeElement);\n      }\n      // if enabled, starts scanning\n      if (_this8._enabled && device) {\n        yield _this8.scanFromDevice(device.deviceId);\n      }\n    })();\n  }\n  /**\n   * Sets the permission value and emits the event.\n   */\n  setPermission(hasPermission) {\n    this.hasPermission = hasPermission;\n    this.permissionResponse.next(hasPermission);\n  }\n}\nZXingScannerComponent.ɵfac = function ZXingScannerComponent_Factory(t) {\n  return new (t || ZXingScannerComponent)();\n};\nZXingScannerComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n  type: ZXingScannerComponent,\n  selectors: [[\"zxing-scanner\"]],\n  viewQuery: function ZXingScannerComponent_Query(rf, ctx) {\n    if (rf & 1) {\n      i0.ɵɵviewQuery(_c0, 7);\n    }\n    if (rf & 2) {\n      let _t;\n      i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.previewElemRef = _t.first);\n    }\n  },\n  inputs: {\n    autofocusEnabled: \"autofocusEnabled\",\n    timeBetweenScans: \"timeBetweenScans\",\n    delayBetweenScanSuccess: \"delayBetweenScanSuccess\",\n    autostart: \"autostart\",\n    previewFitMode: \"previewFitMode\",\n    poster: \"poster\",\n    device: \"device\",\n    formats: \"formats\",\n    videoConstraints: \"videoConstraints\",\n    torch: \"torch\",\n    enable: \"enable\",\n    tryHarder: \"tryHarder\"\n  },\n  outputs: {\n    autostarted: \"autostarted\",\n    autostarting: \"autostarting\",\n    torchCompatible: \"torchCompatible\",\n    scanSuccess: \"scanSuccess\",\n    scanFailure: \"scanFailure\",\n    scanError: \"scanError\",\n    scanComplete: \"scanComplete\",\n    camerasFound: \"camerasFound\",\n    camerasNotFound: \"camerasNotFound\",\n    permissionResponse: \"permissionResponse\",\n    hasDevices: \"hasDevices\",\n    deviceChange: \"deviceChange\"\n  },\n  decls: 6,\n  vars: 3,\n  consts: [[3, \"poster\"], [\"preview\", \"\"]],\n  template: function ZXingScannerComponent_Template(rf, ctx) {\n    if (rf & 1) {\n      i0.ɵɵelementStart(0, \"video\", 0, 1)(2, \"p\");\n      i0.ɵɵtext(3, \" Your browser does not support this feature, please try to upgrade it. \");\n      i0.ɵɵelementEnd();\n      i0.ɵɵelementStart(4, \"p\");\n      i0.ɵɵtext(5, \" Seu navegador n\\xE3o suporta este recurso, por favor tente atualiz\\xE1-lo. \");\n      i0.ɵɵelementEnd()();\n    }\n    if (rf & 2) {\n      i0.ɵɵstyleProp(\"object-fit\", ctx.previewFitMode);\n      i0.ɵɵproperty(\"poster\", ctx.poster, i0.ɵɵsanitizeUrl);\n    }\n  },\n  styles: [\"[_nghost-%COMP%]{display:block}video[_ngcontent-%COMP%]{width:100%;height:auto;object-fit:contain}\"],\n  changeDetection: 0\n});\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(ZXingScannerComponent, [{\n    type: Component,\n    args: [{\n      selector: 'zxing-scanner',\n      changeDetection: ChangeDetectionStrategy.OnPush,\n      template: \"<video #preview [style.object-fit]=\\\"previewFitMode\\\" [poster]=\\\"poster\\\">\\n  <p>\\n    Your browser does not support this feature, please try to upgrade it.\\n  </p>\\n  <p>\\n    Seu navegador n\\u00E3o suporta este recurso, por favor tente atualiz\\u00E1-lo.\\n  </p>\\n</video>\\n\",\n      styles: [\":host{display:block}video{width:100%;height:auto;object-fit:contain}\\n\"]\n    }]\n  }], function () {\n    return [];\n  }, {\n    previewElemRef: [{\n      type: ViewChild,\n      args: ['preview', {\n        static: true\n      }]\n    }],\n    autofocusEnabled: [{\n      type: Input\n    }],\n    timeBetweenScans: [{\n      type: Input\n    }],\n    delayBetweenScanSuccess: [{\n      type: Input\n    }],\n    autostarted: [{\n      type: Output\n    }],\n    autostarting: [{\n      type: Output\n    }],\n    autostart: [{\n      type: Input\n    }],\n    previewFitMode: [{\n      type: Input\n    }],\n    poster: [{\n      type: Input\n    }],\n    torchCompatible: [{\n      type: Output\n    }],\n    scanSuccess: [{\n      type: Output\n    }],\n    scanFailure: [{\n      type: Output\n    }],\n    scanError: [{\n      type: Output\n    }],\n    scanComplete: [{\n      type: Output\n    }],\n    camerasFound: [{\n      type: Output\n    }],\n    camerasNotFound: [{\n      type: Output\n    }],\n    permissionResponse: [{\n      type: Output\n    }],\n    hasDevices: [{\n      type: Output\n    }],\n    device: [{\n      type: Input\n    }],\n    deviceChange: [{\n      type: Output\n    }],\n    formats: [{\n      type: Input\n    }],\n    videoConstraints: [{\n      type: Input\n    }],\n    torch: [{\n      type: Input\n    }],\n    enable: [{\n      type: Input\n    }],\n    tryHarder: [{\n      type: Input\n    }]\n  });\n})();\nclass ZXingScannerModule {}\nZXingScannerModule.ɵfac = function ZXingScannerModule_Factory(t) {\n  return new (t || ZXingScannerModule)();\n};\nZXingScannerModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n  type: ZXingScannerModule\n});\nZXingScannerModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n  imports: [CommonModule, FormsModule]\n});\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(ZXingScannerModule, [{\n    type: NgModule,\n    args: [{\n      imports: [CommonModule, FormsModule],\n      declarations: [ZXingScannerComponent],\n      exports: [ZXingScannerComponent]\n    }]\n  }], null, null);\n})();\n\n/*\n * Public API Surface of zxing-scanner\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { ZXingScannerComponent, ZXingScannerModule };","map":{"version":3,"names":["CommonModule","i0","EventEmitter","Component","ChangeDetectionStrategy","ViewChild","Input","Output","NgModule","FormsModule","BrowserMultiFormatReader","BrowserCodeReader","NotFoundException","ChecksumException","FormatException","DecodeHintType","BarcodeFormat","BehaviorSubject","BrowserMultiFormatContinuousReader","getScannerControls","scannerControls","Error","scanFromDeviceObservable","deviceId","previewEl","scan$","ctrls","decodeFromVideoDevice","result","error","next","errorName","name","message","includes","stop","undefined","complete","e","asObservable","ZXingScannerComponent","codeReader","_codeReader","device","_ready","_devicePreStart","isAutostarting","console","warn","isCurrentDevice","hasPermission","setDevice","_device","formats","hints","get","POSSIBLE_FORMATS","input","map","f","getBarcodeFormatOrFail","set","_hints","setHints","videoConstraints","constraints","controls","streamVideoConstraintsApply","state","_isAutostarting","autostarting","torch","onOff","getCodeReader","switchTorch","enable","enabled","_enabled","Boolean","reset","releaseAllStreams","scanFromDevice","init","tryHarder","TRY_HARDER","delete","constructor","timeBetweenScans","delayBetweenScanSuccess","previewFitMode","poster","autostarted","torchCompatible","scanSuccess","scanFailure","scanError","scanComplete","camerasFound","camerasNotFound","permissionResponse","hasDevices","deviceChange","Map","autofocusEnabled","autostart","QR_CODE","hasNavigator","navigator","isMediaDevicesSupported","mediaDevices","askForPermission","setPermission","stream","permission","getAnyVideoDevice","err","handlePermissionException","terminateStream","getUserMedia","video","getTracks","forEach","t","initAutostartOff","initAutostartOn","updateVideoInputDevices","devices","autostartScanner","ngOnDestroy","ngOnInit","scanStop","_scanSubscription","unsubscribe","scanStart","restart","prevDevice","_reset","listVideoInputDevices","length","matcher","label","test","find","pop","dispatchScanSuccess","getText","dispatchScanFailure","reason","dispatchScanError","observed","dispatchScanComplete","format","trim","toUpperCase","options","delayBetweenScanAttempts","videoElement","previewElemRef","nativeElement","scanStream","x","_onDecodeResult","_onDecodeError","subscribe","closed","hasTorchControl","emit","cleanVideoSource","ɵfac","ɵcmp","type","args","selector","changeDetection","OnPush","template","styles","static","ZXingScannerModule","ɵmod","ɵinj","imports","declarations","exports"],"sources":["C:/Users/Kevin/source/repos/Diplomarbeit-EVG/Diplomarbeit-EVG/ClientApp/node_modules/@zxing/ngx-scanner/fesm2022/zxing-ngx-scanner.mjs"],"sourcesContent":["import { CommonModule } from '@angular/common';\nimport * as i0 from '@angular/core';\nimport { EventEmitter, Component, ChangeDetectionStrategy, ViewChild, Input, Output, NgModule } from '@angular/core';\nimport { FormsModule } from '@angular/forms';\nimport { BrowserMultiFormatReader, BrowserCodeReader } from '@zxing/browser';\nimport { NotFoundException, ChecksumException, FormatException, DecodeHintType, BarcodeFormat } from '@zxing/library';\nimport { BehaviorSubject } from 'rxjs';\n\n/**\n * Based on zxing-typescript BrowserCodeReader\n */\nclass BrowserMultiFormatContinuousReader extends BrowserMultiFormatReader {\n    /**\n     * Returns the code reader scanner controls.\n     */\n    getScannerControls() {\n        if (!this.scannerControls) {\n            throw new Error('No scanning is running at the time.');\n        }\n        return this.scannerControls;\n    }\n    /**\n     * Starts the decoding from the current or a new video element.\n     *\n     * @param deviceId The device's to be used Id\n     * @param previewEl A new video element\n     */\n    async scanFromDeviceObservable(deviceId, previewEl) {\n        const scan$ = new BehaviorSubject({});\n        let ctrls;\n        try {\n            ctrls = await this.decodeFromVideoDevice(deviceId, previewEl, (result, error) => {\n                if (!error) {\n                    scan$.next({ result });\n                    return;\n                }\n                const errorName = error.name;\n                // stream cannot stop on fails.\n                if (\n                // scan Failure - found nothing, no error\n                errorName === NotFoundException.name ||\n                    // scan Error - found the QR but got error on decoding\n                    errorName === ChecksumException.name ||\n                    errorName === FormatException.name ||\n                    error.message.includes('No MultiFormat Readers were able to detect the code.')) {\n                    scan$.next({ error });\n                    return;\n                }\n                // probably fatal error\n                scan$.error(error);\n                this.scannerControls.stop();\n                this.scannerControls = undefined;\n                return;\n            });\n            this.scannerControls = {\n                ...ctrls,\n                stop() {\n                    ctrls.stop();\n                    scan$.complete();\n                },\n            };\n        }\n        catch (e) {\n            scan$.error(e);\n            this.scannerControls?.stop();\n            this.scannerControls = undefined;\n        }\n        return scan$.asObservable();\n    }\n}\n\nclass ZXingScannerComponent {\n    /**\n     * Exposes the current code reader, so the user can use it's APIs.\n     */\n    get codeReader() {\n        return this._codeReader;\n    }\n    /**\n     * User device input\n     */\n    set device(device) {\n        if (!this._ready) {\n            this._devicePreStart = device;\n            // let's ignore silently, users don't like logs\n            return;\n        }\n        if (this.isAutostarting) {\n            // do not allow setting devices during auto-start, since it will set one and emit it.\n            console.warn('Avoid setting a device during auto-start.');\n            return;\n        }\n        if (this.isCurrentDevice(device)) {\n            console.warn('Setting the same device is not allowed.');\n            return;\n        }\n        if (!this.hasPermission) {\n            console.warn('Permissions not set yet, waiting for them to be set to apply device change.');\n            // this.permissionResponse\n            //   .pipe(\n            //     take(1),\n            //     tap(() => console.log(`Permissions set, applying device change${device ? ` (${device.deviceId})` : ''}.`))\n            //   )\n            //   .subscribe(() => this.device = device);\n            return;\n        }\n        this.setDevice(device);\n    }\n    /**\n     * User device accessor.\n     */\n    get device() {\n        return this._device;\n    }\n    /**\n     * Returns all the registered formats.\n     */\n    get formats() {\n        return this.hints.get(DecodeHintType.POSSIBLE_FORMATS);\n    }\n    /**\n     * Registers formats the scanner should support.\n     *\n     * @param input BarcodeFormat or case-insensitive string array.\n     */\n    set formats(input) {\n        if (typeof input === 'string') {\n            throw new Error('Invalid formats, make sure the [formats] input is a binding.');\n        }\n        // formats may be set from html template as BarcodeFormat or string array\n        const formats = input.map(f => this.getBarcodeFormatOrFail(f));\n        const hints = this.hints;\n        // updates the hints\n        hints.set(DecodeHintType.POSSIBLE_FORMATS, formats);\n        // handles updating the codeReader\n        this.hints = hints;\n    }\n    /**\n     * Returns all the registered hints.\n     */\n    get hints() {\n        return this._hints;\n    }\n    /**\n     * Does what it takes to set the hints.\n     */\n    set hints(hints) {\n        this._hints = hints;\n        // new instance with new hints.\n        this.codeReader?.setHints(this._hints);\n    }\n    /**\n     * Sets the desired constraints in all video tracks.\n     * @experimental\n     */\n    set videoConstraints(constraints) {\n        // new instance with new hints.\n        const controls = this.codeReader?.getScannerControls();\n        if (!controls) {\n            // fails silently\n            return;\n        }\n        controls?.streamVideoConstraintsApply(constraints);\n    }\n    /**\n     *\n     */\n    set isAutostarting(state) {\n        this._isAutostarting = state;\n        this.autostarting.next(state);\n    }\n    /**\n     *\n     */\n    get isAutostarting() {\n        return this._isAutostarting;\n    }\n    /**\n     * Can turn on/off the device flashlight.\n     *\n     * @experimental Torch/Flash APIs are not stable in all browsers, it may be buggy!\n     */\n    set torch(onOff) {\n        try {\n            const controls = this.getCodeReader().getScannerControls();\n            controls.switchTorch(onOff);\n        }\n        catch (error) {\n            // ignore error\n        }\n    }\n    /**\n     * Starts and Stops the scanning.\n     */\n    set enable(enabled) {\n        this._enabled = Boolean(enabled);\n        if (!this._enabled) {\n            this.reset();\n            BrowserMultiFormatContinuousReader.releaseAllStreams();\n        }\n        else {\n            if (this.device) {\n                this.scanFromDevice(this.device.deviceId);\n            }\n            else {\n                this.init();\n            }\n        }\n    }\n    /**\n     * Tells if the scanner is enabled or not.\n     */\n    get enabled() {\n        return this._enabled;\n    }\n    /**\n     * If is `tryHarder` enabled.\n     */\n    get tryHarder() {\n        return this.hints.get(DecodeHintType.TRY_HARDER);\n    }\n    /**\n     * Enable/disable tryHarder hint.\n     */\n    set tryHarder(enable) {\n        const hints = this.hints;\n        if (enable) {\n            hints.set(DecodeHintType.TRY_HARDER, true);\n        }\n        else {\n            hints.delete(DecodeHintType.TRY_HARDER);\n        }\n        this.hints = hints;\n    }\n    /**\n     * Constructor to build the object and do some DI.\n     */\n    constructor() {\n        /**\n         * Delay between attempts to decode (default is 500ms)\n         */\n        this.timeBetweenScans = 500;\n        /**\n         * Delay between successful decode (default is 500ms)\n         */\n        this.delayBetweenScanSuccess = 500;\n        /**\n         * How the preview element should be fit inside the :host container.\n         */\n        this.previewFitMode = 'cover';\n        /**\n         * Url of the HTML video poster\n         */\n        this.poster = '';\n        this._ready = false;\n        // instance based emitters\n        this.autostarted = new EventEmitter();\n        this.autostarting = new EventEmitter();\n        this.torchCompatible = new EventEmitter(false);\n        this.scanSuccess = new EventEmitter();\n        this.scanFailure = new EventEmitter();\n        this.scanError = new EventEmitter();\n        this.scanComplete = new EventEmitter();\n        this.camerasFound = new EventEmitter();\n        this.camerasNotFound = new EventEmitter();\n        this.permissionResponse = new EventEmitter(true);\n        this.hasDevices = new EventEmitter();\n        this.deviceChange = new EventEmitter();\n        this._enabled = true;\n        this._hints = new Map();\n        this.autofocusEnabled = true;\n        this.autostart = true;\n        this.formats = [BarcodeFormat.QR_CODE];\n        // computed data\n        this.hasNavigator = typeof navigator !== 'undefined';\n        this.isMediaDevicesSupported = this.hasNavigator && !!navigator.mediaDevices;\n    }\n    /**\n     * Gets and registers all cameras.\n     */\n    async askForPermission() {\n        if (!this.hasNavigator) {\n            console.error('@zxing/ngx-scanner', 'Can\\'t ask permission, navigator is not present.');\n            this.setPermission(null);\n            return this.hasPermission;\n        }\n        if (!this.isMediaDevicesSupported) {\n            console.error('@zxing/ngx-scanner', 'Can\\'t get user media, this is not supported.');\n            this.setPermission(null);\n            return this.hasPermission;\n        }\n        let stream;\n        let permission;\n        try {\n            // Will try to ask for permission\n            stream = await this.getAnyVideoDevice();\n            permission = !!stream;\n        }\n        catch (err) {\n            return this.handlePermissionException(err);\n        }\n        finally {\n            this.terminateStream(stream);\n        }\n        this.setPermission(permission);\n        // Returns the permission\n        return permission;\n    }\n    /**\n     *\n     */\n    getAnyVideoDevice() {\n        return navigator.mediaDevices.getUserMedia({ video: true });\n    }\n    /**\n     * Terminates a stream and it's tracks.\n     */\n    terminateStream(stream) {\n        if (stream) {\n            stream.getTracks().forEach(t => t.stop());\n        }\n        stream = undefined;\n    }\n    async init() {\n        if (!this.autostart) {\n            console.warn('Feature \\'autostart\\' disabled. Permissions and devices recovery has to be run manually.');\n            // does the necessary configuration without autostarting\n            this.initAutostartOff();\n            this._ready = true;\n            return;\n        }\n        // configures the component and starts the scanner\n        await this.initAutostartOn();\n        this._ready = true;\n    }\n    /**\n     * Initializes the component without starting the scanner.\n     */\n    initAutostartOff() {\n        // do not ask for permission when autostart is off\n        this.isAutostarting = false;\n        // just update devices information\n        this.updateVideoInputDevices();\n        if (this._device && this._devicePreStart) {\n            this.setDevice(this._devicePreStart);\n        }\n    }\n    /**\n     * Initializes the component and starts the scanner.\n     * Permissions are asked to accomplish that.\n     */\n    async initAutostartOn() {\n        this.isAutostarting = true;\n        let hasPermission;\n        try {\n            // Asks for permission before enumerating devices so it can get all the device's info\n            hasPermission = await this.askForPermission();\n        }\n        catch (e) {\n            console.error('Exception occurred while asking for permission:', e);\n            return;\n        }\n        // from this point, things gonna need permissions\n        if (hasPermission) {\n            const devices = await this.updateVideoInputDevices();\n            await this.autostartScanner([...devices]);\n        }\n        this.isAutostarting = false;\n        this.autostarted.next();\n    }\n    /**\n     * Checks if the given device is the current defined one.\n     */\n    isCurrentDevice(device) {\n        return device?.deviceId === this._device?.deviceId;\n    }\n    /**\n     * Executes some actions before destroy the component.\n     */\n    ngOnDestroy() {\n        this.reset();\n        BrowserMultiFormatContinuousReader.releaseAllStreams();\n    }\n    /**\n     *\n     */\n    ngOnInit() {\n        this.init();\n    }\n    /**\n     * Stops the scanning, if any.\n     */\n    scanStop() {\n        if (this._scanSubscription) {\n            this.codeReader?.getScannerControls().stop();\n            this._scanSubscription?.unsubscribe();\n            this._scanSubscription = undefined;\n        }\n        this.torchCompatible.next(false);\n    }\n    /**\n     * Stops the scanning, if any.\n     */\n    scanStart() {\n        if (this._scanSubscription) {\n            throw new Error('There is already a scan process running.');\n        }\n        if (!this._device) {\n            throw new Error('No device defined, cannot start scan, please define a device.');\n        }\n        this.scanFromDevice(this._device.deviceId);\n    }\n    /**\n     * Stops old `codeReader` and starts scanning in a new one.\n     */\n    restart() {\n        // note only necessary for now because of the Torch\n        this._codeReader = undefined;\n        const prevDevice = this._reset();\n        if (!prevDevice) {\n            return;\n        }\n        this.device = prevDevice;\n    }\n    /**\n     * Discovers and updates known video input devices.\n     */\n    async updateVideoInputDevices() {\n        // permissions aren't needed to get devices, but to access them and their info\n        const devices = await BrowserCodeReader.listVideoInputDevices() || [];\n        const hasDevices = devices && devices.length > 0;\n        // stores discovered devices and updates information\n        this.hasDevices.next(hasDevices);\n        this.camerasFound.next([...devices]);\n        if (!hasDevices) {\n            this.camerasNotFound.next(null);\n        }\n        return devices;\n    }\n    /**\n     * Starts the scanner with the back camera otherwise take the last\n     * available device.\n     */\n    async autostartScanner(devices) {\n        const matcher = ({ label }) => /back|trás|rear|traseira|environment|ambiente/gi.test(label);\n        // select the rear camera by default, otherwise take the last camera.\n        const device = devices.find(matcher) || devices.pop();\n        if (!device) {\n            throw new Error('Impossible to autostart, no input devices available.');\n        }\n        await this.setDevice(device);\n        this.deviceChange.next(device);\n    }\n    /**\n     * Dispatches the scan success event.\n     *\n     * @param result the scan result.\n     */\n    dispatchScanSuccess(result) {\n        this.scanSuccess.next(result.getText());\n    }\n    /**\n     * Dispatches the scan failure event.\n     */\n    dispatchScanFailure(reason) {\n        this.scanFailure.next(reason);\n    }\n    /**\n     * Dispatches the scan error event.\n     *\n     * @param error the error thing.\n     */\n    dispatchScanError(error) {\n        if (!this.scanError.observed) {\n            console.error(`zxing scanner component: ${error.name}`, error);\n            console.warn('Use the `(scanError)` property to handle errors like this!');\n        }\n        this.scanError.next(error);\n    }\n    /**\n     * Dispatches the scan event.\n     *\n     * @param result the scan result.\n     */\n    dispatchScanComplete(result) {\n        this.scanComplete.next(result);\n    }\n    /**\n     * Returns the filtered permission.\n     */\n    handlePermissionException(err) {\n        // failed to grant permission to video input\n        console.error('@zxing/ngx-scanner', 'Error when asking for permission.', err);\n        let permission;\n        switch (err.name) {\n            // usually caused by not secure origins\n            case 'NotSupportedError':\n                console.warn('@zxing/ngx-scanner', err.message);\n                // could not claim\n                permission = null;\n                // can't check devices\n                this.hasDevices.next(null);\n                break;\n            // user denied permission\n            case 'NotAllowedError':\n                console.warn('@zxing/ngx-scanner', err.message);\n                // claimed and denied permission\n                permission = false;\n                // this means that input devices exists\n                this.hasDevices.next(true);\n                break;\n            // the device has no attached input devices\n            case 'NotFoundError':\n                console.warn('@zxing/ngx-scanner', err.message);\n                // no permissions claimed\n                permission = null;\n                // because there was no devices\n                this.hasDevices.next(false);\n                // tells the listener about the error\n                this.camerasNotFound.next(err);\n                break;\n            case 'NotReadableError':\n                console.warn('@zxing/ngx-scanner', 'Couldn\\'t read the device(s)\\'s stream, it\\'s probably in use by another app.');\n                // no permissions claimed\n                permission = null;\n                // there are devices, which I couldn't use\n                this.hasDevices.next(false);\n                // tells the listener about the error\n                this.camerasNotFound.next(err);\n                break;\n            default:\n                console.warn('@zxing/ngx-scanner', 'I was not able to define if I have permissions for camera or not.', err);\n                // unknown\n                permission = null;\n                // this.hasDevices.next(undefined;\n                break;\n        }\n        this.setPermission(permission);\n        // tells the listener about the error\n        this.permissionResponse.error(err);\n        return permission;\n    }\n    /**\n     * Returns a valid BarcodeFormat or fails.\n     */\n    getBarcodeFormatOrFail(format) {\n        return typeof format === 'string'\n            ? BarcodeFormat[format.trim().toUpperCase()]\n            : format;\n    }\n    /**\n     * Return a code reader, create one if non exist\n     */\n    getCodeReader() {\n        if (!this._codeReader) {\n            const options = {\n                delayBetweenScanAttempts: this.timeBetweenScans,\n                delayBetweenScanSuccess: this.delayBetweenScanSuccess\n            };\n            this._codeReader = new BrowserMultiFormatContinuousReader(this.hints, options);\n        }\n        return this._codeReader;\n    }\n    /**\n     * Starts the continuous scanning for the given device.\n     *\n     * @param deviceId The deviceId from the device.\n     */\n    async scanFromDevice(deviceId) {\n        const videoElement = this.previewElemRef.nativeElement;\n        const codeReader = this.getCodeReader();\n        const scanStream = await codeReader.scanFromDeviceObservable(deviceId, videoElement);\n        if (!scanStream) {\n            throw new Error('Undefined decoding stream, aborting.');\n        }\n        const next = (x) => this._onDecodeResult(x.result, x.error);\n        const error = (err) => this._onDecodeError(err);\n        const complete = () => {\n        };\n        this._scanSubscription = scanStream.subscribe(next, error, complete);\n        if (this._scanSubscription.closed) {\n            return;\n        }\n        const controls = codeReader.getScannerControls();\n        const hasTorchControl = typeof controls.switchTorch !== 'undefined';\n        this.torchCompatible.next(hasTorchControl);\n    }\n    /**\n     * Handles decode errors.\n     */\n    _onDecodeError(err) {\n        this.dispatchScanError(err);\n        // this.reset();\n    }\n    /**\n     * Handles decode results.\n     */\n    _onDecodeResult(result, error) {\n        if (result) {\n            this.dispatchScanSuccess(result);\n        }\n        else {\n            this.dispatchScanFailure(error);\n        }\n        this.dispatchScanComplete(result);\n    }\n    /**\n     * Stops the code reader and returns the previous selected device.\n     */\n    _reset() {\n        if (!this._codeReader) {\n            return;\n        }\n        // clearing codeReader first to prevent setOptions error appearing in several Chromium versions\n        this._codeReader = undefined;\n        const device = this._device;\n        // do not set this.device inside this method, it would create a recursive loop\n        this.device = undefined;\n        return device;\n    }\n    /**\n     * Resets the scanner and emits device change.\n     */\n    reset() {\n        this._reset();\n        this.deviceChange.emit(null);\n    }\n    /**\n     * Sets the current device.\n     */\n    async setDevice(device) {\n        // instantly stops the scan before changing devices\n        this.scanStop();\n        // correctly sets the new (or none) device\n        this._device = device || undefined;\n        if (!this._device) {\n            // cleans the video because user removed the device\n            BrowserCodeReader.cleanVideoSource(this.previewElemRef.nativeElement);\n        }\n        // if enabled, starts scanning\n        if (this._enabled && device) {\n            await this.scanFromDevice(device.deviceId);\n        }\n    }\n    /**\n     * Sets the permission value and emits the event.\n     */\n    setPermission(hasPermission) {\n        this.hasPermission = hasPermission;\n        this.permissionResponse.next(hasPermission);\n    }\n    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"16.2.5\", ngImport: i0, type: ZXingScannerComponent, deps: [], target: i0.ɵɵFactoryTarget.Component }); }\n    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: \"14.0.0\", version: \"16.2.5\", type: ZXingScannerComponent, selector: \"zxing-scanner\", inputs: { autofocusEnabled: \"autofocusEnabled\", timeBetweenScans: \"timeBetweenScans\", delayBetweenScanSuccess: \"delayBetweenScanSuccess\", autostart: \"autostart\", previewFitMode: \"previewFitMode\", poster: \"poster\", device: \"device\", formats: \"formats\", videoConstraints: \"videoConstraints\", torch: \"torch\", enable: \"enable\", tryHarder: \"tryHarder\" }, outputs: { autostarted: \"autostarted\", autostarting: \"autostarting\", torchCompatible: \"torchCompatible\", scanSuccess: \"scanSuccess\", scanFailure: \"scanFailure\", scanError: \"scanError\", scanComplete: \"scanComplete\", camerasFound: \"camerasFound\", camerasNotFound: \"camerasNotFound\", permissionResponse: \"permissionResponse\", hasDevices: \"hasDevices\", deviceChange: \"deviceChange\" }, viewQueries: [{ propertyName: \"previewElemRef\", first: true, predicate: [\"preview\"], descendants: true, static: true }], ngImport: i0, template: \"<video #preview [style.object-fit]=\\\"previewFitMode\\\" [poster]=\\\"poster\\\">\\n  <p>\\n    Your browser does not support this feature, please try to upgrade it.\\n  </p>\\n  <p>\\n    Seu navegador n\\u00E3o suporta este recurso, por favor tente atualiz\\u00E1-lo.\\n  </p>\\n</video>\\n\", styles: [\":host{display:block}video{width:100%;height:auto;object-fit:contain}\\n\"], changeDetection: i0.ChangeDetectionStrategy.OnPush }); }\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"16.2.5\", ngImport: i0, type: ZXingScannerComponent, decorators: [{\n            type: Component,\n            args: [{ selector: 'zxing-scanner', changeDetection: ChangeDetectionStrategy.OnPush, template: \"<video #preview [style.object-fit]=\\\"previewFitMode\\\" [poster]=\\\"poster\\\">\\n  <p>\\n    Your browser does not support this feature, please try to upgrade it.\\n  </p>\\n  <p>\\n    Seu navegador n\\u00E3o suporta este recurso, por favor tente atualiz\\u00E1-lo.\\n  </p>\\n</video>\\n\", styles: [\":host{display:block}video{width:100%;height:auto;object-fit:contain}\\n\"] }]\n        }], ctorParameters: function () { return []; }, propDecorators: { previewElemRef: [{\n                type: ViewChild,\n                args: ['preview', { static: true }]\n            }], autofocusEnabled: [{\n                type: Input\n            }], timeBetweenScans: [{\n                type: Input\n            }], delayBetweenScanSuccess: [{\n                type: Input\n            }], autostarted: [{\n                type: Output\n            }], autostarting: [{\n                type: Output\n            }], autostart: [{\n                type: Input\n            }], previewFitMode: [{\n                type: Input\n            }], poster: [{\n                type: Input\n            }], torchCompatible: [{\n                type: Output\n            }], scanSuccess: [{\n                type: Output\n            }], scanFailure: [{\n                type: Output\n            }], scanError: [{\n                type: Output\n            }], scanComplete: [{\n                type: Output\n            }], camerasFound: [{\n                type: Output\n            }], camerasNotFound: [{\n                type: Output\n            }], permissionResponse: [{\n                type: Output\n            }], hasDevices: [{\n                type: Output\n            }], device: [{\n                type: Input\n            }], deviceChange: [{\n                type: Output\n            }], formats: [{\n                type: Input\n            }], videoConstraints: [{\n                type: Input\n            }], torch: [{\n                type: Input\n            }], enable: [{\n                type: Input\n            }], tryHarder: [{\n                type: Input\n            }] } });\n\nclass ZXingScannerModule {\n    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"16.2.5\", ngImport: i0, type: ZXingScannerModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule }); }\n    static { this.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: \"14.0.0\", version: \"16.2.5\", ngImport: i0, type: ZXingScannerModule, declarations: [ZXingScannerComponent], imports: [CommonModule,\n            FormsModule], exports: [ZXingScannerComponent] }); }\n    static { this.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: \"12.0.0\", version: \"16.2.5\", ngImport: i0, type: ZXingScannerModule, imports: [CommonModule,\n            FormsModule] }); }\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"16.2.5\", ngImport: i0, type: ZXingScannerModule, decorators: [{\n            type: NgModule,\n            args: [{\n                    imports: [\n                        CommonModule,\n                        FormsModule\n                    ],\n                    declarations: [ZXingScannerComponent],\n                    exports: [ZXingScannerComponent],\n                }]\n        }] });\n\n/*\n * Public API Surface of zxing-scanner\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { ZXingScannerComponent, ZXingScannerModule };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}