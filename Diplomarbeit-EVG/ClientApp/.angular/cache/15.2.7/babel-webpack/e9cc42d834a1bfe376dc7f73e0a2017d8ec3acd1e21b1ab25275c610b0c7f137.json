{"ast":null,"code":"import BarcodeFormat from '../BarcodeFormat';\nimport BitMatrix from '../common/BitMatrix';\nimport EncodeHintType from '../EncodeHintType';\nimport ByteMatrix from '../qrcode/encoder/ByteMatrix';\nimport Charset from '../util/Charset';\nimport { DefaultPlacement, ErrorCorrection, HighLevelEncoder, MinimalEncoder, SymbolInfo } from './encoder';\nvar DataMatrixWriter = /** @class */function () {\n  function DataMatrixWriter() {}\n  DataMatrixWriter.prototype.encode = function (contents, format, width, height, hints) {\n    if (hints === void 0) {\n      hints = null;\n    }\n    if (contents.trim() === '') {\n      throw new Error('Found empty contents');\n    }\n    if (format !== BarcodeFormat.DATA_MATRIX) {\n      throw new Error('Can only encode DATA_MATRIX, but got ' + format);\n    }\n    if (width < 0 || height < 0) {\n      throw new Error('Requested dimensions can\\'t be negative: ' + width + 'x' + height);\n    }\n    // Try to get force shape & min / max size\n    var shape = 0 /* FORCE_NONE */;\n    var minSize = null;\n    var maxSize = null;\n    if (hints != null) {\n      var requestedShape = hints.get(EncodeHintType.DATA_MATRIX_SHAPE);\n      if (requestedShape != null) {\n        shape = requestedShape;\n      }\n      var requestedMinSize = hints.get(EncodeHintType.MIN_SIZE);\n      if (requestedMinSize != null) {\n        minSize = requestedMinSize;\n      }\n      var requestedMaxSize = hints.get(EncodeHintType.MAX_SIZE);\n      if (requestedMaxSize != null) {\n        maxSize = requestedMaxSize;\n      }\n    }\n    // 1. step: Data encodation\n    var encoded;\n    var hasCompactionHint = hints != null && hints.has(EncodeHintType.DATA_MATRIX_COMPACT) && Boolean(hints.get(EncodeHintType.DATA_MATRIX_COMPACT).toString());\n    if (hasCompactionHint) {\n      var hasGS1FormatHint = hints.has(EncodeHintType.GS1_FORMAT) && Boolean(hints.get(EncodeHintType.GS1_FORMAT).toString());\n      var charset = null;\n      var hasEncodingHint = hints.has(EncodeHintType.CHARACTER_SET);\n      if (hasEncodingHint) {\n        charset = Charset.forName(hints.get(EncodeHintType.CHARACTER_SET).toString());\n      }\n      encoded = MinimalEncoder.encodeHighLevel(contents, charset, hasGS1FormatHint ? 0x1d : -1, shape);\n    } else {\n      var hasForceC40Hint = hints != null && hints.has(EncodeHintType.FORCE_C40) && Boolean(hints.get(EncodeHintType.FORCE_C40).toString());\n      encoded = HighLevelEncoder.encodeHighLevel(contents, shape, minSize, maxSize, hasForceC40Hint);\n    }\n    var symbolInfo = SymbolInfo.lookup(encoded.length, shape, minSize, maxSize, true);\n    // 2. step: ECC generation\n    var codewords = ErrorCorrection.encodeECC200(encoded, symbolInfo);\n    // 3. step: Module placement in Matrix\n    var placement = new DefaultPlacement(codewords, symbolInfo.getSymbolDataWidth(), symbolInfo.getSymbolDataHeight());\n    placement.place();\n    // 4. step: low-level encoding\n    return this.encodeLowLevel(placement, symbolInfo, width, height);\n  };\n  /**\n   * Encode the given symbol info to a bit matrix.\n   *\n   * @param placement  The DataMatrix placement.\n   * @param symbolInfo The symbol info to encode.\n   * @return The bit matrix generated.\n   */\n  DataMatrixWriter.prototype.encodeLowLevel = function (placement, symbolInfo, width, height) {\n    var symbolWidth = symbolInfo.getSymbolDataWidth();\n    var symbolHeight = symbolInfo.getSymbolDataHeight();\n    var matrix = new ByteMatrix(symbolInfo.getSymbolWidth(), symbolInfo.getSymbolHeight());\n    var matrixY = 0;\n    for (var y = 0; y < symbolHeight; y++) {\n      // Fill the top edge with alternate 0 / 1\n      var matrixX = void 0;\n      if (y % symbolInfo.matrixHeight === 0) {\n        matrixX = 0;\n        for (var x = 0; x < symbolInfo.getSymbolWidth(); x++) {\n          matrix.setBoolean(matrixX, matrixY, x % 2 === 0);\n          matrixX++;\n        }\n        matrixY++;\n      }\n      matrixX = 0;\n      for (var x = 0; x < symbolWidth; x++) {\n        // Fill the right edge with full 1\n        if (x % symbolInfo.matrixWidth === 0) {\n          matrix.setBoolean(matrixX, matrixY, true);\n          matrixX++;\n        }\n        matrix.setBoolean(matrixX, matrixY, placement.getBit(x, y));\n        matrixX++;\n        // Fill the right edge with alternate 0 / 1\n        if (x % symbolInfo.matrixWidth === symbolInfo.matrixWidth - 1) {\n          matrix.setBoolean(matrixX, matrixY, y % 2 === 0);\n          matrixX++;\n        }\n      }\n      matrixY++;\n      // Fill the bottom edge with full 1\n      if (y % symbolInfo.matrixHeight === symbolInfo.matrixHeight - 1) {\n        matrixX = 0;\n        for (var x = 0; x < symbolInfo.getSymbolWidth(); x++) {\n          matrix.setBoolean(matrixX, matrixY, true);\n          matrixX++;\n        }\n        matrixY++;\n      }\n    }\n    return this.convertByteMatrixToBitMatrix(matrix, width, height);\n  };\n  /**\n   * Convert the ByteMatrix to BitMatrix.\n   *\n   * @param reqHeight The requested height of the image (in pixels) with the Datamatrix code\n   * @param reqWidth The requested width of the image (in pixels) with the Datamatrix code\n   * @param matrix The input matrix.\n   * @return The output matrix.\n   */\n  DataMatrixWriter.prototype.convertByteMatrixToBitMatrix = function (matrix, reqWidth, reqHeight) {\n    var matrixWidth = matrix.getWidth();\n    var matrixHeight = matrix.getHeight();\n    var outputWidth = Math.max(reqWidth, matrixWidth);\n    var outputHeight = Math.max(reqHeight, matrixHeight);\n    var multiple = Math.min(outputWidth / matrixWidth, outputHeight / matrixHeight);\n    var leftPadding = (outputWidth - matrixWidth * multiple) / 2;\n    var topPadding = (outputHeight - matrixHeight * multiple) / 2;\n    var output;\n    // remove padding if requested width and height are too small\n    if (reqHeight < matrixHeight || reqWidth < matrixWidth) {\n      leftPadding = 0;\n      topPadding = 0;\n      output = new BitMatrix(matrixWidth, matrixHeight);\n    } else {\n      output = new BitMatrix(reqWidth, reqHeight);\n    }\n    output.clear();\n    for (var inputY = 0, outputY = topPadding; inputY < matrixHeight; inputY++, outputY += multiple) {\n      // Write the contents of this row of the bytematrix\n      for (var inputX = 0, outputX = leftPadding; inputX < matrixWidth; inputX++, outputX += multiple) {\n        if (matrix.get(inputX, inputY) === 1) {\n          output.setRegion(outputX, outputY, multiple, multiple);\n        }\n      }\n    }\n    return output;\n  };\n  return DataMatrixWriter;\n}();\nexport default DataMatrixWriter;","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}