{"ast":null,"code":"var __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n    return extendStatics(d, b);\n  };\n  return function (d, b) {\n    extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\nimport StringUtils from '../../common/StringUtils';\nimport StringBuilder from '../../util/StringBuilder';\nimport { C40Encoder } from './C40Encoder';\nimport HighLevelEncoder from './HighLevelEncoder';\nimport { X12_ENCODATION, ASCII_ENCODATION, X12_UNLATCH } from './constants';\nvar X12Encoder = /** @class */function (_super) {\n  __extends(X12Encoder, _super);\n  function X12Encoder() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n  X12Encoder.prototype.getEncodingMode = function () {\n    return X12_ENCODATION;\n  };\n  X12Encoder.prototype.encode = function (context) {\n    // step C\n    var buffer = new StringBuilder();\n    while (context.hasMoreCharacters()) {\n      var c = context.getCurrentChar();\n      context.pos++;\n      this.encodeChar(c, buffer);\n      var count = buffer.length();\n      if (count % 3 === 0) {\n        this.writeNextTriplet(context, buffer);\n        var newMode = HighLevelEncoder.lookAheadTest(context.getMessage(), context.pos, this.getEncodingMode());\n        if (newMode !== this.getEncodingMode()) {\n          // Return to ASCII encodation, which will actually handle latch to new mode\n          context.signalEncoderChange(ASCII_ENCODATION);\n          break;\n        }\n      }\n    }\n    this.handleEOD(context, buffer);\n  };\n  X12Encoder.prototype.encodeChar = function (c, sb) {\n    switch (c) {\n      case 13:\n        // CR (Carriage return)\n        sb.append(0);\n        break;\n      case '*'.charCodeAt(0):\n        sb.append(1);\n        break;\n      case '>'.charCodeAt(0):\n        sb.append(2);\n        break;\n      case ' '.charCodeAt(0):\n        sb.append(3);\n        break;\n      default:\n        if (c >= '0'.charCodeAt(0) && c <= '9'.charCodeAt(0)) {\n          sb.append(c - 48 + 4);\n        } else if (c >= 'A'.charCodeAt(0) && c <= 'Z'.charCodeAt(0)) {\n          sb.append(c - 65 + 14);\n        } else {\n          HighLevelEncoder.illegalCharacter(StringUtils.getCharAt(c));\n        }\n        break;\n    }\n    return 1;\n  };\n  X12Encoder.prototype.handleEOD = function (context, buffer) {\n    context.updateSymbolInfo();\n    var available = context.getSymbolInfo().getDataCapacity() - context.getCodewordCount();\n    var count = buffer.length();\n    context.pos -= count;\n    if (context.getRemainingCharacters() > 1 || available > 1 || context.getRemainingCharacters() !== available) {\n      context.writeCodeword(X12_UNLATCH);\n    }\n    if (context.getNewEncoding() < 0) {\n      context.signalEncoderChange(ASCII_ENCODATION);\n    }\n  };\n  return X12Encoder;\n}(C40Encoder);\nexport { X12Encoder };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}