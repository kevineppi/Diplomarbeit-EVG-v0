{"ast":null,"code":"// tslint:disable-next-line:no-circular-imports\nimport { ASCIIEncoder } from './ASCIIEncoder';\n// tslint:disable-next-line:no-circular-imports\nimport { Base256Encoder } from './Base256Encoder';\n// tslint:disable-next-line:no-circular-imports\nimport { C40Encoder } from './C40Encoder';\nimport { ASCII_ENCODATION, BASE256_ENCODATION, C40_ENCODATION, EDIFACT_ENCODATION, MACRO_05, MACRO_05_HEADER, MACRO_06, MACRO_06_HEADER, MACRO_TRAILER, PAD, TEXT_ENCODATION, X12_ENCODATION } from './constants';\n// tslint:disable-next-line:no-circular-imports\nimport { EdifactEncoder } from './EdifactEncoder';\nimport { EncoderContext } from './EncoderContext';\n// tslint:disable-next-line:no-circular-imports\nimport { X12Encoder } from './X12Encoder';\n// tslint:disable-next-line:no-circular-imports\nimport { TextEncoder } from './TextEncoder';\nimport Arrays from '../../util/Arrays';\nimport Integer from '../../util/Integer';\n/**\n * DataMatrix ECC 200 data encoder following the algorithm described in ISO/IEC 16022:200(E) in\n * annex S.\n */\nvar HighLevelEncoder = /** @class */function () {\n  function HighLevelEncoder() {}\n  HighLevelEncoder.randomize253State = function (codewordPosition) {\n    var pseudoRandom = 149 * codewordPosition % 253 + 1;\n    var tempVariable = PAD + pseudoRandom;\n    return tempVariable <= 254 ? tempVariable : tempVariable - 254;\n  };\n  /**\n   * Performs message encoding of a DataMatrix message using the algorithm described in annex P\n   * of ISO/IEC 16022:2000(E).\n   *\n   * @param msg     the message\n   * @param shape   requested shape. May be {@code SymbolShapeHint.FORCE_NONE},\n   *                {@code SymbolShapeHint.FORCE_SQUARE} or {@code SymbolShapeHint.FORCE_RECTANGLE}.\n   * @param minSize the minimum symbol size constraint or null for no constraint\n   * @param maxSize the maximum symbol size constraint or null for no constraint\n   * @param forceC40 enforce C40 encoding\n   * @return the encoded message (the char values range from 0 to 255)\n   */\n  HighLevelEncoder.encodeHighLevel = function (msg, shape, minSize, maxSize, forceC40) {\n    if (shape === void 0) {\n      shape = 0 /* FORCE_NONE */;\n    }\n    if (minSize === void 0) {\n      minSize = null;\n    }\n    if (maxSize === void 0) {\n      maxSize = null;\n    }\n    if (forceC40 === void 0) {\n      forceC40 = false;\n    }\n    // the codewords 0..255 are encoded as Unicode characters\n    var c40Encoder = new C40Encoder();\n    var encoders = [new ASCIIEncoder(), c40Encoder, new TextEncoder(), new X12Encoder(), new EdifactEncoder(), new Base256Encoder()];\n    var context = new EncoderContext(msg);\n    context.setSymbolShape(shape);\n    context.setSizeConstraints(minSize, maxSize);\n    if (msg.startsWith(MACRO_05_HEADER) && msg.endsWith(MACRO_TRAILER)) {\n      context.writeCodeword(MACRO_05);\n      context.setSkipAtEnd(2);\n      context.pos += MACRO_05_HEADER.length;\n    } else if (msg.startsWith(MACRO_06_HEADER) && msg.endsWith(MACRO_TRAILER)) {\n      context.writeCodeword(MACRO_06);\n      context.setSkipAtEnd(2);\n      context.pos += MACRO_06_HEADER.length;\n    }\n    var encodingMode = ASCII_ENCODATION; // Default mode\n    if (forceC40) {\n      c40Encoder.encodeMaximal(context);\n      encodingMode = context.getNewEncoding();\n      context.resetEncoderSignal();\n    }\n    while (context.hasMoreCharacters()) {\n      encoders[encodingMode].encode(context);\n      if (context.getNewEncoding() >= 0) {\n        encodingMode = context.getNewEncoding();\n        context.resetEncoderSignal();\n      }\n    }\n    var len = context.getCodewordCount();\n    context.updateSymbolInfo();\n    var capacity = context.getSymbolInfo().getDataCapacity();\n    if (len < capacity && encodingMode !== ASCII_ENCODATION && encodingMode !== BASE256_ENCODATION && encodingMode !== EDIFACT_ENCODATION) {\n      context.writeCodeword('\\u00fe'); // Unlatch (254)\n    }\n    // Padding\n    var codewords = context.getCodewords();\n    if (codewords.length() < capacity) {\n      codewords.append(PAD);\n    }\n    while (codewords.length() < capacity) {\n      codewords.append(this.randomize253State(codewords.length() + 1));\n    }\n    return context.getCodewords().toString();\n  };\n  HighLevelEncoder.lookAheadTest = function (msg, startpos, currentMode) {\n    var newMode = this.lookAheadTestIntern(msg, startpos, currentMode);\n    if (currentMode === X12_ENCODATION && newMode === X12_ENCODATION) {\n      var endpos = Math.min(startpos + 3, msg.length);\n      for (var i = startpos; i < endpos; i++) {\n        if (!this.isNativeX12(msg.charCodeAt(i))) {\n          return ASCII_ENCODATION;\n        }\n      }\n    } else if (currentMode === EDIFACT_ENCODATION && newMode === EDIFACT_ENCODATION) {\n      var endpos = Math.min(startpos + 4, msg.length);\n      for (var i = startpos; i < endpos; i++) {\n        if (!this.isNativeEDIFACT(msg.charCodeAt(i))) {\n          return ASCII_ENCODATION;\n        }\n      }\n    }\n    return newMode;\n  };\n  HighLevelEncoder.lookAheadTestIntern = function (msg, startpos, currentMode) {\n    if (startpos >= msg.length) {\n      return currentMode;\n    }\n    var charCounts;\n    // step J\n    if (currentMode === ASCII_ENCODATION) {\n      charCounts = [0, 1, 1, 1, 1, 1.25];\n    } else {\n      charCounts = [1, 2, 2, 2, 2, 2.25];\n      charCounts[currentMode] = 0;\n    }\n    var charsProcessed = 0;\n    var mins = new Uint8Array(6);\n    var intCharCounts = [];\n    while (true) {\n      // step K\n      if (startpos + charsProcessed === msg.length) {\n        Arrays.fill(mins, 0);\n        Arrays.fill(intCharCounts, 0);\n        var min = this.findMinimums(charCounts, intCharCounts, Integer.MAX_VALUE, mins);\n        var minCount = this.getMinimumCount(mins);\n        if (intCharCounts[ASCII_ENCODATION] === min) {\n          return ASCII_ENCODATION;\n        }\n        if (minCount === 1) {\n          if (mins[BASE256_ENCODATION] > 0) {\n            return BASE256_ENCODATION;\n          }\n          if (mins[EDIFACT_ENCODATION] > 0) {\n            return EDIFACT_ENCODATION;\n          }\n          if (mins[TEXT_ENCODATION] > 0) {\n            return TEXT_ENCODATION;\n          }\n          if (mins[X12_ENCODATION] > 0) {\n            return X12_ENCODATION;\n          }\n        }\n        return C40_ENCODATION;\n      }\n      var c = msg.charCodeAt(startpos + charsProcessed);\n      charsProcessed++;\n      // step L\n      if (this.isDigit(c)) {\n        charCounts[ASCII_ENCODATION] += 0.5;\n      } else if (this.isExtendedASCII(c)) {\n        charCounts[ASCII_ENCODATION] = Math.ceil(charCounts[ASCII_ENCODATION]);\n        charCounts[ASCII_ENCODATION] += 2.0;\n      } else {\n        charCounts[ASCII_ENCODATION] = Math.ceil(charCounts[ASCII_ENCODATION]);\n        charCounts[ASCII_ENCODATION]++;\n      }\n      // step M\n      if (this.isNativeC40(c)) {\n        charCounts[C40_ENCODATION] += 2.0 / 3.0;\n      } else if (this.isExtendedASCII(c)) {\n        charCounts[C40_ENCODATION] += 8.0 / 3.0;\n      } else {\n        charCounts[C40_ENCODATION] += 4.0 / 3.0;\n      }\n      // step N\n      if (this.isNativeText(c)) {\n        charCounts[TEXT_ENCODATION] += 2.0 / 3.0;\n      } else if (this.isExtendedASCII(c)) {\n        charCounts[TEXT_ENCODATION] += 8.0 / 3.0;\n      } else {\n        charCounts[TEXT_ENCODATION] += 4.0 / 3.0;\n      }\n      // step O\n      if (this.isNativeX12(c)) {\n        charCounts[X12_ENCODATION] += 2.0 / 3.0;\n      } else if (this.isExtendedASCII(c)) {\n        charCounts[X12_ENCODATION] += 13.0 / 3.0;\n      } else {\n        charCounts[X12_ENCODATION] += 10.0 / 3.0;\n      }\n      // step P\n      if (this.isNativeEDIFACT(c)) {\n        charCounts[EDIFACT_ENCODATION] += 3.0 / 4.0;\n      } else if (this.isExtendedASCII(c)) {\n        charCounts[EDIFACT_ENCODATION] += 17.0 / 4.0;\n      } else {\n        charCounts[EDIFACT_ENCODATION] += 13.0 / 4.0;\n      }\n      // step Q\n      if (this.isSpecialB256(c)) {\n        charCounts[BASE256_ENCODATION] += 4.0;\n      } else {\n        charCounts[BASE256_ENCODATION]++;\n      }\n      // step R\n      if (charsProcessed >= 4) {\n        Arrays.fill(mins, 0);\n        Arrays.fill(intCharCounts, 0);\n        this.findMinimums(charCounts, intCharCounts, Integer.MAX_VALUE, mins);\n        if (intCharCounts[ASCII_ENCODATION] < this.min(intCharCounts[BASE256_ENCODATION], intCharCounts[C40_ENCODATION], intCharCounts[TEXT_ENCODATION], intCharCounts[X12_ENCODATION], intCharCounts[EDIFACT_ENCODATION])) {\n          return ASCII_ENCODATION;\n        }\n        if (intCharCounts[BASE256_ENCODATION] < intCharCounts[ASCII_ENCODATION] || intCharCounts[BASE256_ENCODATION] + 1 < this.min(intCharCounts[C40_ENCODATION], intCharCounts[TEXT_ENCODATION], intCharCounts[X12_ENCODATION], intCharCounts[EDIFACT_ENCODATION])) {\n          return BASE256_ENCODATION;\n        }\n        if (intCharCounts[EDIFACT_ENCODATION] + 1 < this.min(intCharCounts[BASE256_ENCODATION], intCharCounts[C40_ENCODATION], intCharCounts[TEXT_ENCODATION], intCharCounts[X12_ENCODATION], intCharCounts[ASCII_ENCODATION])) {\n          return EDIFACT_ENCODATION;\n        }\n        if (intCharCounts[TEXT_ENCODATION] + 1 < this.min(intCharCounts[BASE256_ENCODATION], intCharCounts[C40_ENCODATION], intCharCounts[EDIFACT_ENCODATION], intCharCounts[X12_ENCODATION], intCharCounts[ASCII_ENCODATION])) {\n          return TEXT_ENCODATION;\n        }\n        if (intCharCounts[X12_ENCODATION] + 1 < this.min(intCharCounts[BASE256_ENCODATION], intCharCounts[C40_ENCODATION], intCharCounts[EDIFACT_ENCODATION], intCharCounts[TEXT_ENCODATION], intCharCounts[ASCII_ENCODATION])) {\n          return X12_ENCODATION;\n        }\n        if (intCharCounts[C40_ENCODATION] + 1 < this.min(intCharCounts[ASCII_ENCODATION], intCharCounts[BASE256_ENCODATION], intCharCounts[EDIFACT_ENCODATION], intCharCounts[TEXT_ENCODATION])) {\n          if (intCharCounts[C40_ENCODATION] < intCharCounts[X12_ENCODATION]) {\n            return C40_ENCODATION;\n          }\n          if (intCharCounts[C40_ENCODATION] === intCharCounts[X12_ENCODATION]) {\n            var p = startpos + charsProcessed + 1;\n            while (p < msg.length) {\n              var tc = msg.charCodeAt(p);\n              if (this.isX12TermSep(tc)) {\n                return X12_ENCODATION;\n              }\n              if (!this.isNativeX12(tc)) {\n                break;\n              }\n              p++;\n            }\n            return C40_ENCODATION;\n          }\n        }\n      }\n    }\n  };\n  HighLevelEncoder.min = function (f1, f2, f3, f4, f5) {\n    var val = Math.min(f1, Math.min(f2, Math.min(f3, f4)));\n    if (f5 === undefined) {\n      return val;\n    } else {\n      return Math.min(val, f5);\n    }\n  };\n  HighLevelEncoder.findMinimums = function (charCounts, intCharCounts, min, mins) {\n    for (var i = 0; i < 6; i++) {\n      var current = intCharCounts[i] = Math.ceil(charCounts[i]);\n      if (min > current) {\n        min = current;\n        Arrays.fill(mins, 0);\n      }\n      if (min === current) {\n        mins[i] = mins[i] + 1;\n      }\n    }\n    return min;\n  };\n  HighLevelEncoder.getMinimumCount = function (mins) {\n    var minCount = 0;\n    for (var i = 0; i < 6; i++) {\n      minCount += mins[i];\n    }\n    return minCount || 0;\n  };\n  HighLevelEncoder.isDigit = function (ch) {\n    return ch >= '0'.charCodeAt(0) && ch <= '9'.charCodeAt(0);\n  };\n  HighLevelEncoder.isExtendedASCII = function (ch) {\n    return ch >= 128 && ch <= 255;\n  };\n  HighLevelEncoder.isNativeC40 = function (ch) {\n    return ch === ' '.charCodeAt(0) || ch >= '0'.charCodeAt(0) && ch <= '9'.charCodeAt(0) || ch >= 'A'.charCodeAt(0) && ch <= 'Z'.charCodeAt(0);\n  };\n  HighLevelEncoder.isNativeText = function (ch) {\n    return ch === ' '.charCodeAt(0) || ch >= '0'.charCodeAt(0) && ch <= '9'.charCodeAt(0) || ch >= 'a'.charCodeAt(0) && ch <= 'z'.charCodeAt(0);\n  };\n  HighLevelEncoder.isNativeX12 = function (ch) {\n    return this.isX12TermSep(ch) || ch === ' '.charCodeAt(0) || ch >= '0'.charCodeAt(0) && ch <= '9'.charCodeAt(0) || ch >= 'A'.charCodeAt(0) && ch <= 'Z'.charCodeAt(0);\n  };\n  HighLevelEncoder.isX12TermSep = function (ch) {\n    return ch === 13 ||\n    // CR\n    ch === '*'.charCodeAt(0) || ch === '>'.charCodeAt(0);\n  };\n  HighLevelEncoder.isNativeEDIFACT = function (ch) {\n    return ch >= ' '.charCodeAt(0) && ch <= '^'.charCodeAt(0);\n  };\n  HighLevelEncoder.isSpecialB256 = function (ch) {\n    return false; // TODO NOT IMPLEMENTED YET!!!\n  };\n  /**\n   * Determines the number of consecutive characters that are encodable using numeric compaction.\n   *\n   * @param msg      the message\n   * @param startpos the start position within the message\n   * @return the requested character count\n   */\n  HighLevelEncoder.determineConsecutiveDigitCount = function (msg, startpos) {\n    if (startpos === void 0) {\n      startpos = 0;\n    }\n    var len = msg.length;\n    var idx = startpos;\n    while (idx < len && this.isDigit(msg.charCodeAt(idx))) {\n      idx++;\n    }\n    return idx - startpos;\n  };\n  HighLevelEncoder.illegalCharacter = function (singleCharacter) {\n    var hex = Integer.toHexString(singleCharacter.charCodeAt(0));\n    hex = '0000'.substring(0, 4 - hex.length) + hex;\n    throw new Error('Illegal character: ' + singleCharacter + ' (0x' + hex + ')');\n  };\n  return HighLevelEncoder;\n}();\nexport default HighLevelEncoder;","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}