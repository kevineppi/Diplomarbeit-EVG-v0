{"ast":null,"code":"import StringUtils from '../../common/StringUtils';\nimport StringBuilder from '../../util/StringBuilder';\nimport { EDIFACT_ENCODATION, ASCII_ENCODATION } from './constants';\nimport HighLevelEncoder from './HighLevelEncoder';\nvar EdifactEncoder = /** @class */function () {\n  function EdifactEncoder() {}\n  EdifactEncoder.prototype.getEncodingMode = function () {\n    return EDIFACT_ENCODATION;\n  };\n  EdifactEncoder.prototype.encode = function (context) {\n    // step F\n    var buffer = new StringBuilder();\n    while (context.hasMoreCharacters()) {\n      var c = context.getCurrentChar();\n      this.encodeChar(c, buffer);\n      context.pos++;\n      var count = buffer.length();\n      if (count >= 4) {\n        context.writeCodewords(this.encodeToCodewords(buffer.toString()));\n        var test_1 = buffer.toString().substring(4);\n        buffer.setLengthToZero();\n        buffer.append(test_1);\n        // buffer.delete(0, 4);\n        // for (let i = 0; i < 4; i++) {\n        //  buffer.deleteCharAt(i);\n        // }\n        var newMode = HighLevelEncoder.lookAheadTest(context.getMessage(), context.pos, this.getEncodingMode());\n        if (newMode !== this.getEncodingMode()) {\n          // Return to ASCII encodation, which will actually handle latch to new mode\n          context.signalEncoderChange(ASCII_ENCODATION);\n          break;\n        }\n      }\n    }\n    buffer.append(StringUtils.getCharAt(31)); // Unlatch\n    this.handleEOD(context, buffer);\n  };\n  /**\n   * Handle \"end of data\" situations\n   *\n   * @param context the encoder context\n   * @param buffer  the buffer with the remaining encoded characters\n   */\n  EdifactEncoder.prototype.handleEOD = function (context, buffer) {\n    try {\n      var count = buffer.length();\n      if (count === 0) {\n        return; // Already finished\n      }\n\n      if (count === 1) {\n        // Only an unlatch at the end\n        context.updateSymbolInfo();\n        var available = context.getSymbolInfo().getDataCapacity() - context.getCodewordCount();\n        var remaining = context.getRemainingCharacters();\n        // The following two lines are a hack inspired by the 'fix' from https://sourceforge.net/p/barcode4j/svn/221/\n        if (remaining > available) {\n          context.updateSymbolInfo(context.getCodewordCount() + 1);\n          available = context.getSymbolInfo().getDataCapacity() - context.getCodewordCount();\n        }\n        if (remaining <= available && available <= 2) {\n          return; // No unlatch\n        }\n      }\n\n      if (count > 4) {\n        throw new Error('Count must not exceed 4');\n      }\n      var restChars = count - 1;\n      var encoded = this.encodeToCodewords(buffer.toString());\n      var endOfSymbolReached = !context.hasMoreCharacters();\n      var restInAscii = endOfSymbolReached && restChars <= 2;\n      if (restChars <= 2) {\n        context.updateSymbolInfo(context.getCodewordCount() + restChars);\n        var available = context.getSymbolInfo().getDataCapacity() - context.getCodewordCount();\n        if (available >= 3) {\n          restInAscii = false;\n          context.updateSymbolInfo(context.getCodewordCount() + encoded.length);\n          // available = context.symbolInfo.dataCapacity - context.getCodewordCount();\n        }\n      }\n\n      if (restInAscii) {\n        context.resetSymbolInfo();\n        context.pos -= restChars;\n      } else {\n        context.writeCodewords(encoded);\n      }\n    } finally {\n      context.signalEncoderChange(ASCII_ENCODATION);\n    }\n  };\n  EdifactEncoder.prototype.encodeChar = function (c, sb) {\n    if (c >= ' '.charCodeAt(0) && c <= '?'.charCodeAt(0)) {\n      sb.append(c);\n    } else if (c >= '@'.charCodeAt(0) && c <= '^'.charCodeAt(0)) {\n      sb.append(StringUtils.getCharAt(c - 64));\n    } else {\n      HighLevelEncoder.illegalCharacter(StringUtils.getCharAt(c));\n    }\n  };\n  EdifactEncoder.prototype.encodeToCodewords = function (sb) {\n    var len = sb.length;\n    if (len === 0) {\n      throw new Error('StringBuilder must not be empty');\n    }\n    var c1 = sb.charAt(0).charCodeAt(0);\n    var c2 = len >= 2 ? sb.charAt(1).charCodeAt(0) : 0;\n    var c3 = len >= 3 ? sb.charAt(2).charCodeAt(0) : 0;\n    var c4 = len >= 4 ? sb.charAt(3).charCodeAt(0) : 0;\n    var v = (c1 << 18) + (c2 << 12) + (c3 << 6) + c4;\n    var cw1 = v >> 16 & 255;\n    var cw2 = v >> 8 & 255;\n    var cw3 = v & 255;\n    var res = new StringBuilder();\n    res.append(cw1);\n    if (len >= 2) {\n      res.append(cw2);\n    }\n    if (len >= 3) {\n      res.append(cw3);\n    }\n    return res.toString();\n  };\n  return EdifactEncoder;\n}();\nexport { EdifactEncoder };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}