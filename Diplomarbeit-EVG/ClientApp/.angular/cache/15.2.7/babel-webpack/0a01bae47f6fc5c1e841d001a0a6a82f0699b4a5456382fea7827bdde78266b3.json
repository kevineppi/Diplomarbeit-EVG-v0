{"ast":null,"code":"/**\n * Set of CharsetEncoders for a given input string\n *\n * Invariants:\n * - The list contains only encoders from CharacterSetECI (list is shorter then the list of encoders available on\n *   the platform for which ECI values are defined).\n * - The list contains encoders at least one encoder for every character in the input.\n * - The first encoder in the list is always the ISO-8859-1 encoder even of no character in the input can be encoded\n *       by it.\n * - If the input contains a character that is not in ISO-8859-1 then the last two entries in the list will be the\n *   UTF-8 encoder and the UTF-16BE encoder.\n *\n * @author Alex Geller\n */\nvar __values = this && this.__values || function (o) {\n  var s = typeof Symbol === \"function\" && Symbol.iterator,\n    m = s && o[s],\n    i = 0;\n  if (m) return m.call(o);\n  if (o && typeof o.length === \"number\") return {\n    next: function () {\n      if (o && i >= o.length) o = void 0;\n      return {\n        value: o && o[i++],\n        done: !o\n      };\n    }\n  };\n  throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nimport Charset from '../util/Charset';\nimport StandardCharsets from '../util/StandardCharsets';\nimport StringEncoding from '../util/StringEncoding';\nimport StringUtils from './StringUtils';\nvar CharsetEncoder = /** @class */function () {\n  function CharsetEncoder(charset) {\n    this.charset = charset;\n    this.name = charset.name;\n  }\n  CharsetEncoder.prototype.canEncode = function (c) {\n    try {\n      return StringEncoding.encode(c, this.charset) != null;\n    } catch (ex) {\n      return false;\n    }\n  };\n  return CharsetEncoder;\n}();\nvar ECIEncoderSet = /** @class */function () {\n  /**\n   * Constructs an encoder set\n   *\n   * @param stringToEncode the string that needs to be encoded\n   * @param priorityCharset The preferred {@link Charset} or null.\n   * @param fnc1 fnc1 denotes the character in the input that represents the FNC1 character or -1 for a non-GS1 bar\n   * code. When specified, it is considered an error to pass it as argument to the methods canEncode() or encode().\n   */\n  function ECIEncoderSet(stringToEncode, priorityCharset, fnc1) {\n    var e_1, _a, e_2, _b, e_3, _c;\n    this.ENCODERS = ['IBM437', 'ISO-8859-2', 'ISO-8859-3', 'ISO-8859-4', 'ISO-8859-5', 'ISO-8859-6', 'ISO-8859-7', 'ISO-8859-8', 'ISO-8859-9', 'ISO-8859-10', 'ISO-8859-11', 'ISO-8859-13', 'ISO-8859-14', 'ISO-8859-15', 'ISO-8859-16', 'windows-1250', 'windows-1251', 'windows-1252', 'windows-1256', 'Shift_JIS'].map(function (name) {\n      return new CharsetEncoder(Charset.forName(name));\n    });\n    this.encoders = [];\n    var neededEncoders = [];\n    // we always need the ISO-8859-1 encoder. It is the default encoding\n    neededEncoders.push(new CharsetEncoder(StandardCharsets.ISO_8859_1));\n    var needUnicodeEncoder = priorityCharset != null && priorityCharset.name.startsWith('UTF');\n    // Walk over the input string and see if all characters can be encoded with the list of encoders\n    for (var i = 0; i < stringToEncode.length; i++) {\n      var canEncode = false;\n      try {\n        for (var neededEncoders_1 = (e_1 = void 0, __values(neededEncoders)), neededEncoders_1_1 = neededEncoders_1.next(); !neededEncoders_1_1.done; neededEncoders_1_1 = neededEncoders_1.next()) {\n          var encoder = neededEncoders_1_1.value;\n          var singleCharacter = stringToEncode.charAt(i);\n          var c = singleCharacter.charCodeAt(0);\n          if (c === fnc1 || encoder.canEncode(singleCharacter)) {\n            canEncode = true;\n            break;\n          }\n        }\n      } catch (e_1_1) {\n        e_1 = {\n          error: e_1_1\n        };\n      } finally {\n        try {\n          if (neededEncoders_1_1 && !neededEncoders_1_1.done && (_a = neededEncoders_1.return)) _a.call(neededEncoders_1);\n        } finally {\n          if (e_1) throw e_1.error;\n        }\n      }\n      if (!canEncode) {\n        try {\n          // for the character at position i we don't yet have an encoder in the list\n          for (var _d = (e_2 = void 0, __values(this.ENCODERS)), _e = _d.next(); !_e.done; _e = _d.next()) {\n            var encoder = _e.value;\n            if (encoder.canEncode(stringToEncode.charAt(i))) {\n              // Good, we found an encoder that can encode the character. We add him to the list and continue scanning\n              // the input\n              neededEncoders.push(encoder);\n              canEncode = true;\n              break;\n            }\n          }\n        } catch (e_2_1) {\n          e_2 = {\n            error: e_2_1\n          };\n        } finally {\n          try {\n            if (_e && !_e.done && (_b = _d.return)) _b.call(_d);\n          } finally {\n            if (e_2) throw e_2.error;\n          }\n        }\n      }\n      if (!canEncode) {\n        // The character is not encodeable by any of the single byte encoders so we remember that we will need a\n        // Unicode encoder.\n        needUnicodeEncoder = true;\n      }\n    }\n    if (neededEncoders.length === 1 && !needUnicodeEncoder) {\n      // the entire input can be encoded by the ISO-8859-1 encoder\n      this.encoders = [neededEncoders[0]];\n    } else {\n      // we need more than one single byte encoder or we need a Unicode encoder.\n      // In this case we append a UTF-8 and UTF-16 encoder to the list\n      this.encoders = [];\n      var index = 0;\n      try {\n        for (var neededEncoders_2 = __values(neededEncoders), neededEncoders_2_1 = neededEncoders_2.next(); !neededEncoders_2_1.done; neededEncoders_2_1 = neededEncoders_2.next()) {\n          var encoder = neededEncoders_2_1.value;\n          this.encoders[index++] = encoder;\n        }\n      } catch (e_3_1) {\n        e_3 = {\n          error: e_3_1\n        };\n      } finally {\n        try {\n          if (neededEncoders_2_1 && !neededEncoders_2_1.done && (_c = neededEncoders_2.return)) _c.call(neededEncoders_2);\n        } finally {\n          if (e_3) throw e_3.error;\n        }\n      }\n      // this.encoders[index] = new CharsetEncoder(StandardCharsets.UTF_8);\n      // this.encoders[index + 1] = new CharsetEncoder(StandardCharsets.UTF_16BE);\n    }\n    // Compute priorityEncoderIndex by looking up priorityCharset in encoders\n    var priorityEncoderIndexValue = -1;\n    if (priorityCharset != null) {\n      for (var i = 0; i < this.encoders.length; i++) {\n        if (this.encoders[i] != null && priorityCharset.name === this.encoders[i].name) {\n          priorityEncoderIndexValue = i;\n          break;\n        }\n      }\n    }\n    this.priorityEncoderIndex = priorityEncoderIndexValue;\n    // invariants\n    // if(this?.encoders?.[0].name !== StandardCharsets.ISO_8859_1)){\n    // throw new Error(\"ISO-8859-1 must be the first encoder\");\n    // }\n  }\n\n  ECIEncoderSet.prototype.length = function () {\n    return this.encoders.length;\n  };\n  ECIEncoderSet.prototype.getCharsetName = function (index) {\n    if (!(index < this.length())) {\n      throw new Error('index must be less than length');\n    }\n    return this.encoders[index].name;\n  };\n  ECIEncoderSet.prototype.getCharset = function (index) {\n    if (!(index < this.length())) {\n      throw new Error('index must be less than length');\n    }\n    return this.encoders[index].charset;\n  };\n  ECIEncoderSet.prototype.getECIValue = function (encoderIndex) {\n    return this.encoders[encoderIndex].charset.getValueIdentifier();\n  };\n  /*\n   *  returns -1 if no priority charset was defined\n   */\n  ECIEncoderSet.prototype.getPriorityEncoderIndex = function () {\n    return this.priorityEncoderIndex;\n  };\n  ECIEncoderSet.prototype.canEncode = function (c, encoderIndex) {\n    if (!(encoderIndex < this.length())) {\n      throw new Error('index must be less than length');\n    }\n    return true;\n  };\n  ECIEncoderSet.prototype.encode = function (c, encoderIndex) {\n    if (!(encoderIndex < this.length())) {\n      throw new Error('index must be less than length');\n    }\n    return StringEncoding.encode(StringUtils.getCharAt(c), this.encoders[encoderIndex].name);\n  };\n  return ECIEncoderSet;\n}();\nexport { ECIEncoderSet };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}