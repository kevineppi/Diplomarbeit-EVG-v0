{"ast":null,"code":"import { ECIEncoderSet } from './ECIEncoderSet';\nimport Integer from '../util/Integer';\nimport StringBuilder from '../util/StringBuilder';\nvar COST_PER_ECI = 3; // approximated (latch + 2 codewords)\nvar MinimalECIInput = /** @class */function () {\n  /**\n   * Constructs a minimal input\n   *\n   * @param stringToEncode the character string to encode\n   * @param priorityCharset The preferred {@link Charset}. When the value of the argument is null, the algorithm\n   *   chooses charsets that leads to a minimal representation. Otherwise the algorithm will use the priority\n   *   charset to encode any character in the input that can be encoded by it if the charset is among the\n   *   supported charsets.\n   * @param fnc1 denotes the character in the input that represents the FNC1 character or -1 if this is not GS1\n   *   input.\n   */\n  function MinimalECIInput(stringToEncode, priorityCharset, fnc1) {\n    this.fnc1 = fnc1;\n    var encoderSet = new ECIEncoderSet(stringToEncode, priorityCharset, fnc1);\n    if (encoderSet.length() === 1) {\n      // optimization for the case when all can be encoded without ECI in ISO-8859-1\n      for (var i = 0; i < this.bytes.length; i++) {\n        var c = stringToEncode.charAt(i).charCodeAt(0);\n        this.bytes[i] = c === fnc1 ? 1000 : c;\n      }\n    } else {\n      this.bytes = this.encodeMinimally(stringToEncode, encoderSet, fnc1);\n    }\n  }\n  MinimalECIInput.prototype.getFNC1Character = function () {\n    return this.fnc1;\n  };\n  /**\n   * Returns the length of this input.  The length is the number\n   * of {@code byte}s, FNC1 characters or ECIs in the sequence.\n   *\n   * @return  the number of {@code char}s in this sequence\n   */\n  MinimalECIInput.prototype.length = function () {\n    return this.bytes.length;\n  };\n  MinimalECIInput.prototype.haveNCharacters = function (index, n) {\n    if (index + n - 1 >= this.bytes.length) {\n      return false;\n    }\n    for (var i = 0; i < n; i++) {\n      if (this.isECI(index + i)) {\n        return false;\n      }\n    }\n    return true;\n  };\n  /**\n   * Returns the {@code byte} value at the specified index.  An index ranges from zero\n   * to {@code length() - 1}.  The first {@code byte} value of the sequence is at\n   * index zero, the next at index one, and so on, as for array\n   * indexing.\n   *\n   * @param   index the index of the {@code byte} value to be returned\n   *\n   * @return  the specified {@code byte} value as character or the FNC1 character\n   *\n   * @throws  IndexOutOfBoundsException\n   *          if the {@code index} argument is negative or not less than\n   *          {@code length()}\n   * @throws  IllegalArgumentException\n   *          if the value at the {@code index} argument is an ECI (@see #isECI)\n   */\n  MinimalECIInput.prototype.charAt = function (index) {\n    if (index < 0 || index >= this.length()) {\n      throw new Error('' + index);\n    }\n    if (this.isECI(index)) {\n      throw new Error('value at ' + index + ' is not a character but an ECI');\n    }\n    return this.isFNC1(index) ? this.fnc1 : this.bytes[index];\n  };\n  /**\n   * Returns a {@code CharSequence} that is a subsequence of this sequence.\n   * The subsequence starts with the {@code char} value at the specified index and\n   * ends with the {@code char} value at index {@code end - 1}.  The length\n   * (in {@code char}s) of the\n   * returned sequence is {@code end - start}, so if {@code start == end}\n   * then an empty sequence is returned.\n   *\n   * @param   start   the start index, inclusive\n   * @param   end     the end index, exclusive\n   *\n   * @return  the specified subsequence\n   *\n   * @throws  IndexOutOfBoundsException\n   *          if {@code start} or {@code end} are negative,\n   *          if {@code end} is greater than {@code length()},\n   *          or if {@code start} is greater than {@code end}\n   * @throws  IllegalArgumentException\n   *          if a value in the range {@code start}-{@code end} is an ECI (@see #isECI)\n   */\n  MinimalECIInput.prototype.subSequence = function (start, end) {\n    if (start < 0 || start > end || end > this.length()) {\n      throw new Error('' + start);\n    }\n    var result = new StringBuilder();\n    for (var i = start; i < end; i++) {\n      if (this.isECI(i)) {\n        throw new Error('value at ' + i + ' is not a character but an ECI');\n      }\n      result.append(this.charAt(i));\n    }\n    return result.toString();\n  };\n  /**\n   * Determines if a value is an ECI\n   *\n   * @param   index the index of the value\n   *\n   * @return  true if the value at position {@code index} is an ECI\n   *\n   * @throws  IndexOutOfBoundsException\n   *          if the {@code index} argument is negative or not less than\n   *          {@code length()}\n   */\n  MinimalECIInput.prototype.isECI = function (index) {\n    if (index < 0 || index >= this.length()) {\n      throw new Error('' + index);\n    }\n    return this.bytes[index] > 255 && this.bytes[index] <= 999;\n  };\n  /**\n   * Determines if a value is the FNC1 character\n   *\n   * @param   index the index of the value\n   *\n   * @return  true if the value at position {@code index} is the FNC1 character\n   *\n   * @throws  IndexOutOfBoundsException\n   *          if the {@code index} argument is negative or not less than\n   *          {@code length()}\n   */\n  MinimalECIInput.prototype.isFNC1 = function (index) {\n    if (index < 0 || index >= this.length()) {\n      throw new Error('' + index);\n    }\n    return this.bytes[index] === 1000;\n  };\n  /**\n   * Returns the {@code int} ECI value at the specified index.  An index ranges from zero\n   * to {@code length() - 1}.  The first {@code byte} value of the sequence is at\n   * index zero, the next at index one, and so on, as for array\n   * indexing.\n   *\n   * @param   index the index of the {@code int} value to be returned\n   *\n   * @return  the specified {@code int} ECI value.\n   *          The ECI specified the encoding of all bytes with a higher index until the\n   *          next ECI or until the end of the input if no other ECI follows.\n   *\n   * @throws  IndexOutOfBoundsException\n   *          if the {@code index} argument is negative or not less than\n   *          {@code length()}\n   * @throws  IllegalArgumentException\n   *          if the value at the {@code index} argument is not an ECI (@see #isECI)\n   */\n  MinimalECIInput.prototype.getECIValue = function (index) {\n    if (index < 0 || index >= this.length()) {\n      throw new Error('' + index);\n    }\n    if (!this.isECI(index)) {\n      throw new Error('value at ' + index + ' is not an ECI but a character');\n    }\n    return this.bytes[index] - 256;\n  };\n  MinimalECIInput.prototype.addEdge = function (edges, to, edge) {\n    if (edges[to][edge.encoderIndex] == null || edges[to][edge.encoderIndex].cachedTotalSize > edge.cachedTotalSize) {\n      edges[to][edge.encoderIndex] = edge;\n    }\n  };\n  MinimalECIInput.prototype.addEdges = function (stringToEncode, encoderSet, edges, from, previous, fnc1) {\n    var ch = stringToEncode.charAt(from).charCodeAt(0);\n    var start = 0;\n    var end = encoderSet.length();\n    if (encoderSet.getPriorityEncoderIndex() >= 0 && (ch === fnc1 || encoderSet.canEncode(ch, encoderSet.getPriorityEncoderIndex()))) {\n      start = encoderSet.getPriorityEncoderIndex();\n      end = start + 1;\n    }\n    for (var i = start; i < end; i++) {\n      if (ch === fnc1 || encoderSet.canEncode(ch, i)) {\n        this.addEdge(edges, from + 1, new InputEdge(ch, encoderSet, i, previous, fnc1));\n      }\n    }\n  };\n  MinimalECIInput.prototype.encodeMinimally = function (stringToEncode, encoderSet, fnc1) {\n    var inputLength = stringToEncode.length;\n    // Array that represents vertices. There is a vertex for every character and encoding.\n    var edges = new InputEdge[inputLength + 1][encoderSet.length()]();\n    this.addEdges(stringToEncode, encoderSet, edges, 0, null, fnc1);\n    for (var i = 1; i <= inputLength; i++) {\n      for (var j = 0; j < encoderSet.length(); j++) {\n        if (edges[i][j] != null && i < inputLength) {\n          this.addEdges(stringToEncode, encoderSet, edges, i, edges[i][j], fnc1);\n        }\n      }\n      // optimize memory by removing edges that have been passed.\n      for (var j = 0; j < encoderSet.length(); j++) {\n        edges[i - 1][j] = null;\n      }\n    }\n    var minimalJ = -1;\n    var minimalSize = Integer.MAX_VALUE;\n    for (var j = 0; j < encoderSet.length(); j++) {\n      if (edges[inputLength][j] != null) {\n        var edge = edges[inputLength][j];\n        if (edge.cachedTotalSize < minimalSize) {\n          minimalSize = edge.cachedTotalSize;\n          minimalJ = j;\n        }\n      }\n    }\n    if (minimalJ < 0) {\n      throw new Error('Failed to encode \"' + stringToEncode + '\"');\n    }\n    var intsAL = [];\n    var current = edges[inputLength][minimalJ];\n    while (current != null) {\n      if (current.isFNC1()) {\n        intsAL.unshift(1000);\n      } else {\n        var bytes = encoderSet.encode(current.c, current.encoderIndex);\n        for (var i = bytes.length - 1; i >= 0; i--) {\n          intsAL.unshift(bytes[i] & 0xff);\n        }\n      }\n      var previousEncoderIndex = current.previous === null ? 0 : current.previous.encoderIndex;\n      if (previousEncoderIndex !== current.encoderIndex) {\n        intsAL.unshift(256 + encoderSet.getECIValue(current.encoderIndex));\n      }\n      current = current.previous;\n    }\n    var ints = [];\n    for (var i = 0; i < ints.length; i++) {\n      ints[i] = intsAL[i];\n    }\n    return ints;\n  };\n  return MinimalECIInput;\n}();\nexport { MinimalECIInput };\nvar InputEdge = /** @class */function () {\n  function InputEdge(c, encoderSet, encoderIndex, previous, fnc1) {\n    this.c = c;\n    this.encoderSet = encoderSet;\n    this.encoderIndex = encoderIndex;\n    this.previous = previous;\n    this.fnc1 = fnc1;\n    this.c = c === fnc1 ? 1000 : c;\n    var size = this.isFNC1() ? 1 : encoderSet.encode(c, encoderIndex).length;\n    var previousEncoderIndex = previous === null ? 0 : previous.encoderIndex;\n    if (previousEncoderIndex !== encoderIndex) {\n      size += COST_PER_ECI;\n    }\n    if (previous != null) {\n      size += previous.cachedTotalSize;\n    }\n    this.cachedTotalSize = size;\n  }\n  InputEdge.prototype.isFNC1 = function () {\n    return this.c === 1000;\n  };\n  return InputEdge;\n}();","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}